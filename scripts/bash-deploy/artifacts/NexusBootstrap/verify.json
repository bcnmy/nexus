{"language":"Solidity","sources":{"contracts/utils/NexusBootstrap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. For security issues, contact: security@biconomy.io\n\nimport { ModuleManager } from \"../base/ModuleManager.sol\";\nimport { IModule } from \"../interfaces/modules/IModule.sol\";\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n/// @title NexusBootstrap Configuration for Nexus\n/// @notice Provides configuration and initialization for Nexus smart accounts.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nstruct BootstrapConfig {\n    address module;\n    bytes data;\n}\n\n/// @title NexusBootstrap\n/// @notice Manages the installation of modules into Nexus smart accounts using delegatecalls.\ncontract NexusBootstrap is ModuleManager {\n    /// @notice Initializes the Nexus account with a single validator.\n    /// @dev Intended to be called by the Nexus with a delegatecall.\n    /// @param validator The address of the validator module.\n    /// @param data The initialization data for the validator module.\n    function initNexusWithSingleValidator(\n        IModule validator,\n        bytes calldata data,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external {\n        _configureRegistry(registry, attesters, threshold);\n        _installValidator(address(validator), data);\n    }\n\n    /// @notice Initializes the Nexus account with multiple modules.\n    /// @dev Intended to be called by the Nexus with a delegatecall.\n    /// @param validators The configuration array for validator modules.\n    /// @param executors The configuration array for executor modules.\n    /// @param hook The configuration for the hook module.\n    /// @param fallbacks The configuration array for fallback handler modules.\n    function initNexus(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig[] calldata executors,\n        BootstrapConfig calldata hook,\n        BootstrapConfig[] calldata fallbacks,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external {\n        _configureRegistry(registry, attesters, threshold);\n\n        // Initialize validators\n        for (uint256 i = 0; i < validators.length; i++) {\n            _installValidator(validators[i].module, validators[i].data);\n        }\n\n        // Initialize executors\n        for (uint256 i = 0; i < executors.length; i++) {\n            if (executors[i].module == address(0)) continue;\n            _installExecutor(executors[i].module, executors[i].data);\n        }\n\n        // Initialize hook\n        if (hook.module != address(0)) {\n            _installHook(hook.module, hook.data);\n        }\n\n        // Initialize fallback handlers\n        for (uint256 i = 0; i < fallbacks.length; i++) {\n            if (fallbacks[i].module == address(0)) continue;\n            _installFallbackHandler(fallbacks[i].module, fallbacks[i].data);\n        }\n    }\n\n    /// @notice Initializes the Nexus account with a scoped set of modules.\n    /// @dev Intended to be called by the Nexus with a delegatecall.\n    /// @param validators The configuration array for validator modules.\n    /// @param hook The configuration for the hook module.\n    function initNexusScoped(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig calldata hook,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external {\n        _configureRegistry(registry, attesters, threshold);\n\n        // Initialize validators\n        for (uint256 i = 0; i < validators.length; i++) {\n            _installValidator(validators[i].module, validators[i].data);\n        }\n\n        // Initialize hook\n        if (hook.module != address(0)) {\n            _installHook(hook.module, hook.data);\n        }\n    }\n\n    /// @notice Prepares calldata for the initNexus function.\n    /// @param validators The configuration array for validator modules.\n    /// @param executors The configuration array for executor modules.\n    /// @param hook The configuration for the hook module.\n    /// @param fallbacks The configuration array for fallback handler modules.\n    /// @return init The prepared calldata for initNexus.\n    function getInitNexusCalldata(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig[] calldata executors,\n        BootstrapConfig calldata hook,\n        BootstrapConfig[] calldata fallbacks,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (bytes memory init) {\n        init = abi.encode(address(this), abi.encodeCall(this.initNexus, (validators, executors, hook, fallbacks, registry, attesters, threshold)));\n    }\n\n    /// @notice Prepares calldata for the initNexusScoped function.\n    /// @param validators The configuration array for validator modules.\n    /// @param hook The configuration for the hook module.\n    /// @return init The prepared calldata for initNexusScoped.\n    function getInitNexusScopedCalldata(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig calldata hook,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (bytes memory init) {\n        init = abi.encode(address(this), abi.encodeCall(this.initNexusScoped, (validators, hook, registry, attesters, threshold)));\n    }\n\n    /// @notice Prepares calldata for the initNexusWithSingleValidator function.\n    /// @param validator The configuration for the validator module.\n    /// @return init The prepared calldata for initNexusWithSingleValidator.\n    function getInitNexusWithSingleValidatorCalldata(\n        BootstrapConfig calldata validator,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (bytes memory init) {\n        init = abi.encode(\n            address(this),\n            abi.encodeCall(this.initNexusWithSingleValidator, (IModule(validator.module), validator.data, registry, attesters, threshold))\n        );\n    }\n\n    /// @dev EIP712 domain name and version.\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        name = \"NexusBootstrap\";\n        version = \"1.0.0\";\n    }\n}\n"},"contracts/base/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { IHook } from \"../interfaces/modules/IHook.sol\";\nimport { IModule } from \"../interfaces/modules/IModule.sol\";\nimport { IExecutor } from \"../interfaces/modules/IExecutor.sol\";\nimport { IFallback } from \"../interfaces/modules/IFallback.sol\";\nimport { IValidator } from \"../interfaces/modules/IValidator.sol\";\nimport { CallType, CALLTYPE_SINGLE, CALLTYPE_STATIC } from \"../lib/ModeLib.sol\";\nimport { ExecLib } from \"../lib/ExecLib.sol\";\nimport { LocalCallDataParserLib } from \"../lib/local/LocalCallDataParserLib.sol\";\nimport { IModuleManagerEventsAndErrors } from \"../interfaces/base/IModuleManagerEventsAndErrors.sol\";\nimport { MODULE_TYPE_VALIDATOR, MODULE_TYPE_EXECUTOR, MODULE_TYPE_FALLBACK, MODULE_TYPE_HOOK, MODULE_TYPE_MULTI, MODULE_ENABLE_MODE_TYPE_HASH, ERC1271_MAGICVALUE } from \"../types/Constants.sol\";\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/ExcessivelySafeCall.sol\";\nimport { RegistryAdapter } from \"./RegistryAdapter.sol\";\n\n/// @title Nexus - ModuleManager\n/// @notice Manages Validator, Executor, Hook, and Fallback modules within the Nexus suite, supporting\n/// @dev Implements SentinelList for managing modules via a linked list structure, adhering to ERC-7579.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nabstract contract ModuleManager is Storage, EIP712, IModuleManagerEventsAndErrors, RegistryAdapter {\n    using SentinelListLib for SentinelListLib.SentinelList;\n    using LocalCallDataParserLib for bytes;\n    using ExecLib for address;\n    using ExcessivelySafeCall for address;\n\n    /// @notice Ensures the message sender is a registered executor module.\n    modifier onlyExecutorModule() virtual {\n        require(_getAccountStorage().executors.contains(msg.sender), InvalidModule(msg.sender));\n        _;\n    }\n\n    /// @notice Does pre-checks and post-checks using an installed hook on the account.\n    /// @dev sender, msg.data and msg.value is passed to the hook to implement custom flows.\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            _;\n            IHook(hook).postCheck(hookData);\n        }\n    }\n\n    receive() external payable {}\n\n    /// @dev Fallback function to manage incoming calls using designated handlers based on the call type.\n    /// Hooked manually in the _fallback function\n    fallback() external payable {\n        _fallback(msg.data);\n    }\n\n    /// @dev Retrieves a paginated list of validator addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of validator modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of validator addresses to return.\n    /// @return array An array of validator addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getValidatorsPaginated(address cursor, uint256 size) external view returns (address[] memory array, address next) {\n        (array, next) = _paginate(_getAccountStorage().validators, cursor, size);\n    }\n\n    /// @dev Retrieves a paginated list of executor addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of executor modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of executor addresses to return.\n    /// @return array An array of executor addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getExecutorsPaginated(address cursor, uint256 size) external view returns (address[] memory array, address next) {\n        (array, next) = _paginate(_getAccountStorage().executors, cursor, size);\n    }\n\n    /// @notice Retrieves the currently active hook address.\n    /// @return hook The address of the active hook module.\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n\n    /// @notice Fetches the fallback handler for a specific selector.\n    /// @param selector The function selector to query.\n    /// @return calltype The type of call that the handler manages.\n    /// @return handler The address of the fallback handler.\n    function getFallbackHandlerBySelector(bytes4 selector) external view returns (CallType, address) {\n        FallbackHandler memory handler = _getAccountStorage().fallbacks[selector];\n        return (handler.calltype, handler.handler);\n    }\n\n    /// @dev Initializes the module manager by setting up default states for validators and executors.\n    function _initModuleManager() internal virtual {\n        // account module storage\n        AccountStorage storage ams = _getAccountStorage();\n        ams.executors.init();\n        ams.validators.init();\n    }\n\n    /// @dev Implements Module Enable Mode flow.\n    /// @param packedData Data source to parse data required to perform Module Enable mode from.\n    /// @return userOpSignature the clean signature which can be further used for userOp validation\n    function _enableMode(bytes32 userOpHash, bytes calldata packedData) internal returns (bytes calldata userOpSignature) {\n        address module;\n        uint256 moduleType;\n        bytes calldata moduleInitData;\n        bytes calldata enableModeSignature;\n\n        (module, moduleType, moduleInitData, enableModeSignature, userOpSignature) = packedData.parseEnableModeData();\n\n        if (!_checkEnableModeSignature(_getEnableModeDataHash(module, moduleType, userOpHash, moduleInitData), enableModeSignature))\n            revert EnableModeSigError();\n\n        _installModule(moduleType, module, moduleInitData);\n    }\n\n    /// @notice Installs a new module to the smart account.\n    /// @param moduleTypeId The type identifier of the module being installed, which determines its role:\n    /// - 0 for MultiType\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// @param module The address of the module to install.\n    /// @param initData Initialization data for the module.\n    /// @dev This function goes through hook checks via withHook modifier.\n    /// @dev No need to check that the module is already installed, as this check is done\n    /// when trying to sstore the module in an appropriate SentinelList\n    function _installModule(uint256 moduleTypeId, address module, bytes calldata initData) internal withHook {\n        if (module == address(0)) revert ModuleAddressCanNotBeZero();\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _installValidator(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _installExecutor(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _installFallbackHandler(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _installHook(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_MULTI) {\n            _multiTypeInstall(module, initData);\n        } else {\n            revert InvalidModuleTypeId(moduleTypeId);\n        }\n    }\n\n    /// @dev Installs a new validator module after checking if it matches the required module type.\n    /// @param validator The address of the validator module to be installed.\n    /// @param data Initialization data to configure the validator upon installation.\n    function _installValidator(address validator, bytes calldata data) internal virtual withRegistry(validator, MODULE_TYPE_VALIDATOR) {\n        if (!IValidator(validator).isModuleType(MODULE_TYPE_VALIDATOR)) revert MismatchModuleTypeId(MODULE_TYPE_VALIDATOR);\n        _getAccountStorage().validators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    /// @dev Uninstalls a validator module /!\\ ensuring the account retains at least one validator.\n    /// @param validator The address of the validator to be uninstalled.\n    /// @param data De-initialization data to configure the validator upon uninstallation.\n    function _uninstallValidator(address validator, bytes calldata data) internal virtual {\n        SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n\n        // Perform the removal first\n        validators.pop(prev, validator);\n\n        // Sentinel pointing to itself / zero means the list is empty / uninitialized, so check this after removal\n        // Below error is very specific to uninstalling validators.\n        require(_hasValidators(), CanNotRemoveLastValidator());\n        validator.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData));\n    }\n\n    /// @dev Installs a new executor module after checking if it matches the required module type.\n    /// @param executor The address of the executor module to be installed.\n    /// @param data Initialization data to configure the executor upon installation.\n    function _installExecutor(address executor, bytes calldata data) internal virtual withRegistry(executor, MODULE_TYPE_EXECUTOR) {\n        if (!IExecutor(executor).isModuleType(MODULE_TYPE_EXECUTOR)) revert MismatchModuleTypeId(MODULE_TYPE_EXECUTOR);\n        _getAccountStorage().executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    /// @dev Uninstalls an executor module by removing it from the executors list.\n    /// @param executor The address of the executor to be uninstalled.\n    /// @param data De-initialization data to configure the executor upon uninstallation.\n    function _uninstallExecutor(address executor, bytes calldata data) internal virtual {\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        _getAccountStorage().executors.pop(prev, executor);\n        executor.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData));\n    }\n\n    /// @dev Installs a hook module, ensuring no other hooks are installed before proceeding.\n    /// @param hook The address of the hook to be installed.\n    /// @param data Initialization data to configure the hook upon installation.\n    function _installHook(address hook, bytes calldata data) internal virtual withRegistry(hook, MODULE_TYPE_HOOK) {\n        if (!IHook(hook).isModuleType(MODULE_TYPE_HOOK)) revert MismatchModuleTypeId(MODULE_TYPE_HOOK);\n        address currentHook = _getHook();\n        require(currentHook == address(0), HookAlreadyInstalled(currentHook));\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    /// @dev Uninstalls a hook module, ensuring the current hook matches the one intended for uninstallation.\n    /// @param hook The address of the hook to be uninstalled.\n    /// @param data De-initialization data to configure the hook upon uninstallation.\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\n        _setHook(address(0));\n        hook.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data));\n    }\n\n    /// @dev Sets the current hook in the storage to the specified address.\n    /// @param hook The new hook address.\n    function _setHook(address hook) internal virtual {\n        _getAccountStorage().hook = IHook(hook);\n    }\n\n    /// @dev Installs a fallback handler for a given selector with initialization data.\n    /// @param handler The address of the fallback handler to install.\n    /// @param params The initialization parameters including the selector and call type.\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual withRegistry(handler, MODULE_TYPE_FALLBACK) {\n        if (!IFallback(handler).isModuleType(MODULE_TYPE_FALLBACK)) revert MismatchModuleTypeId(MODULE_TYPE_FALLBACK);\n        // Extract the function selector from the provided parameters.\n        bytes4 selector = bytes4(params[0:4]);\n\n        // Extract the call type from the provided parameters.\n        CallType calltype = CallType.wrap(bytes1(params[4]));\n\n        require(calltype == CALLTYPE_SINGLE || calltype == CALLTYPE_STATIC, FallbackCallTypeInvalid());\n\n        // Extract the initialization data from the provided parameters.\n        bytes memory initData = params[5:];\n\n        // Revert if the selector is either `onInstall(bytes)` (0x6d61fe70) or `onUninstall(bytes)` (0x8a91b0e3) or explicit bytes(0).\n        // These selectors are explicitly forbidden to prevent security vulnerabilities.\n        // Allowing these selectors would enable unauthorized users to uninstall and reinstall critical modules.\n        // If a validator module is uninstalled and reinstalled without proper authorization, it can compromise\n        // the account's security and integrity. By restricting these selectors, we ensure that the fallback handler\n        // cannot be manipulated to disrupt the expected behavior and security of the account.\n        require(!(selector == bytes4(0x6d61fe70) || selector == bytes4(0x8a91b0e3) || selector == bytes4(0)), FallbackSelectorForbidden());\n\n        // Revert if a fallback handler is already installed for the given selector.\n        // This check ensures that we do not overwrite an existing fallback handler, which could lead to unexpected behavior.\n        require(!_isFallbackHandlerInstalled(selector), FallbackAlreadyInstalledForSelector(selector));\n\n        // Store the fallback handler and its call type in the account storage.\n        // This maps the function selector to the specified fallback handler and call type.\n        _getAccountStorage().fallbacks[selector] = FallbackHandler(handler, calltype);\n\n        // Invoke the `onInstall` function of the fallback handler with the provided initialization data.\n        // This step allows the fallback handler to perform any necessary setup or initialization.\n        IFallback(handler).onInstall(initData);\n    }\n\n    /// @dev Uninstalls a fallback handler for a given selector.\n    /// @param fallbackHandler The address of the fallback handler to uninstall.\n    /// @param data The de-initialization data containing the selector.\n    function _uninstallFallbackHandler(address fallbackHandler, bytes calldata data) internal virtual {\n        _getAccountStorage().fallbacks[bytes4(data[0:4])] = FallbackHandler(address(0), CallType.wrap(0x00));\n        fallbackHandler.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data[4:]));\n    }\n\n    /// @notice Installs a module with multiple types in a single operation.\n    /// @dev This function handles installing a multi-type module by iterating through each type and initializing it.\n    /// The initData should include an ABI-encoded tuple of (uint[] types, bytes[] initDatas).\n    /// @param module The address of the multi-type module.\n    /// @param initData Initialization data for each type within the module.\n    function _multiTypeInstall(address module, bytes calldata initData) internal virtual {\n        (uint256[] calldata types, bytes[] calldata initDatas) = initData.parseMultiTypeInitData();\n\n        uint256 length = types.length;\n        if (initDatas.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 theType = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (theType == MODULE_TYPE_VALIDATOR) {\n                _installValidator(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_EXECUTOR) {\n                _installExecutor(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_FALLBACK) {\n                _installFallbackHandler(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK (global only, not sig-specific)      */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_HOOK) {\n                _installHook(module, initDatas[i]);\n            }\n        }\n    }\n\n    /// @notice Checks if an enable mode signature is valid.\n    /// @param structHash data hash.\n    /// @param sig Signature.\n    function _checkEnableModeSignature(bytes32 structHash, bytes calldata sig) internal view returns (bool) {\n        address enableModeSigValidator = address(bytes20(sig[0:20]));\n        if (!_isValidatorInstalled(enableModeSigValidator)) {\n            revert ValidatorNotInstalled(enableModeSigValidator);\n        }\n        bytes32 eip712Digest = _hashTypedData(structHash);\n\n        // Use standard IERC-1271/ERC-7739 interface.\n        // Even if the validator doesn't support 7739 under the hood, it is still secure,\n        // as eip712digest is already built based on 712Domain of this Smart Account\n        // This interface should always be exposed by validators as per ERC-7579\n        try IValidator(enableModeSigValidator).isValidSignatureWithSender(address(this), eip712Digest, sig[20:]) returns (bytes4 res) {\n            return res == ERC1271_MAGICVALUE;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Builds the enable mode data hash as per eip712\n    /// @param module Module being enabled\n    /// @param moduleType Type of the module as per EIP-7579\n    /// @param userOpHash Hash of the User Operation\n    /// @param initData Module init data.\n    /// @return structHash data hash\n    function _getEnableModeDataHash(address module, uint256 moduleType, bytes32 userOpHash, bytes calldata initData) internal view returns (bytes32) {\n        return keccak256(abi.encode(MODULE_ENABLE_MODE_TYPE_HASH, module, moduleType, userOpHash, keccak256(initData)));\n    }\n\n    /// @notice Checks if a module is installed on the smart account.\n    /// @param moduleTypeId The module type ID.\n    /// @param module The module address.\n    /// @param additionalContext Additional context for checking installation.\n    /// @return True if the module is installed, false otherwise.\n    function _isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) internal view returns (bool) {\n        additionalContext;\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            if (additionalContext.length >= 4) {\n                selector = bytes4(additionalContext[0:4]);\n            } else {\n                selector = bytes4(0x00000000);\n            }\n            return _isFallbackHandlerInstalled(selector, module);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev Checks if a fallback handler is set for a given selector.\n    /// @param selector The function selector to check.\n    /// @return True if a fallback handler is set, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector) internal view virtual returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler != address(0);\n    }\n\n    /// @dev Checks if the expected fallback handler is installed for a given selector.\n    /// @param selector The function selector to check.\n    /// @param expectedHandler The address of the handler expected to be installed.\n    /// @return True if the installed handler matches the expected handler, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector, address expectedHandler) internal view returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler == expectedHandler;\n    }\n\n    /// @dev Checks if a validator is currently installed.\n    /// @param validator The address of the validator to check.\n    /// @return True if the validator is installed, otherwise false.\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\n        return _getAccountStorage().validators.contains(validator);\n    }\n\n    /// @dev Checks if there is at least one validator installed.\n    /// @return True if there is at least one validator, otherwise false.\n    function _hasValidators() internal view returns (bool) {\n        return\n            _getAccountStorage().validators.getNext(address(0x01)) != address(0x01) &&\n            _getAccountStorage().validators.getNext(address(0x01)) != address(0x00);\n    }\n\n    /// @dev Checks if an executor is currently installed.\n    /// @param executor The address of the executor to check.\n    /// @return True if the executor is installed, otherwise false.\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\n        return _getAccountStorage().executors.contains(executor);\n    }\n\n    /// @dev Checks if a hook is currently installed.\n    /// @param hook The address of the hook to check.\n    /// @return True if the hook is installed, otherwise false.\n    function _isHookInstalled(address hook) internal view returns (bool) {\n        return _getHook() == hook;\n    }\n\n    /// @dev Retrieves the current hook from the storage.\n    /// @return hook The address of the current hook.\n    function _getHook() internal view returns (address hook) {\n        hook = address(_getAccountStorage().hook);\n    }\n\n    function _fallback(bytes calldata callData) private {\n        bool success;\n        bytes memory result;\n        FallbackHandler storage $fallbackHandler = _getAccountStorage().fallbacks[msg.sig];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n\n        if (handler != address(0)) {\n            // hook manually\n            address hook = _getHook();\n            bytes memory hookData;\n            if (hook != address(0)) {\n                hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            }\n            //if there's a fallback handler, call it\n            if (calltype == CALLTYPE_STATIC) {\n                (success, result) = handler.staticcall(ExecLib.get2771CallData(callData));\n            } else if (calltype == CALLTYPE_SINGLE) {\n                (success, result) = handler.call{ value: msg.value }(ExecLib.get2771CallData(callData));\n            } else {\n                revert UnsupportedCallType(calltype);\n            }\n\n            // Use revert message from fallback handler if the call was not successful\n            assembly {\n                if iszero(success) {\n                    revert(add(result, 0x20), mload(result))\n                }\n            }\n\n            // hook post check\n            if (hook != address(0)) {\n                IHook(hook).postCheck(hookData);\n            }\n\n            // return the result\n            assembly {\n                return(add(result, 0x20), mload(result))\n            }\n        }\n        \n        // If there's no handler, the call can be one of onERCXXXReceived()\n        // No need to hook this as no execution is done here\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        // if there was no handler and it is not the onERCXXXReceived call, revert\n        revert MissingFallbackHandler(msg.sig);\n    }\n\n    /// @dev Helper function to paginate entries in a SentinelList.\n    /// @param list The SentinelList to paginate.\n    /// @param cursor The cursor to start paginating from.\n    /// @param size The number of entries to return.\n    /// @return array The array of addresses in the list.\n    /// @return nextCursor The cursor for the next page of entries.\n    function _paginate(\n        SentinelListLib.SentinelList storage list,\n        address cursor,\n        uint256 size\n    ) private view returns (address[] memory array, address nextCursor) {\n        (array, nextCursor) = list.getEntriesPaginated(cursor, size);\n    }\n}\n"},"contracts/interfaces/modules/IModule.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Nexus - ERC-7579 Module Base Interface\n/// @notice Interface for module management in smart accounts, complying with ERC-7579 specifications.\n/// @dev Defines the lifecycle hooks and checks for modules within the smart account architecture.\n/// This interface includes methods for installing, uninstalling, and verifying module types and initialization status.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModule {\n    /// @notice Installs the module with necessary initialization data.\n    /// @dev Reverts if the module is already initialized.\n    /// @param data Arbitrary data required for initializing the module during `onInstall`.\n    function onInstall(bytes calldata data) external;\n\n    /// @notice Uninstalls the module and allows for cleanup via arbitrary data.\n    /// @dev Reverts if any issues occur that prevent clean uninstallation.\n    /// @param data Arbitrary data required for deinitializing the module during `onUninstall`.\n    function onUninstall(bytes calldata data) external;\n\n    /// @notice Determines if the module matches a specific module type.\n    /// @dev Should return true if the module corresponds to the type ID, false otherwise.\n    /// @param moduleTypeId Numeric ID of the module type as per ERC-7579 specifications.\n    /// @return True if the module is of the specified type, false otherwise.\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /// @notice Checks if the module has been initialized for a specific smart account.\n    /// @dev Returns true if initialized, false otherwise.\n    /// @param smartAccount Address of the smart account to check for initialization status.\n    /// @return True if the module is initialized for the given smart account, false otherwise.\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n"},"contracts/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IERC7484 {\n    event NewTrustedAttesters();\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(address smartAccount, address module, uint256 moduleType) external view;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(address module, uint256 moduleType, address[] calldata attesters, uint256 threshold) external view;\n}\n"},"node_modules/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"contracts/base/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IStorage } from \"../interfaces/base/IStorage.sol\";\n\n/// @title Nexus - Storage\n/// @notice Manages isolated storage spaces for Modular Smart Account in compliance with ERC-7201 standard to ensure collision-resistant storage.\n/// @dev Implements the ERC-7201 namespaced storage pattern to maintain secure and isolated storage sections for different states within Nexus suite.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Storage is IStorage {\n    /// @custom:storage-location erc7201:biconomy.storage.Nexus\n    /// ERC-7201 namespaced via `keccak256(abi.encode(uint256(keccak256(bytes(\"biconomy.storage.Nexus\"))) - 1)) & ~bytes32(uint256(0xff));`\n    bytes32 private constant _STORAGE_LOCATION = 0x0bb70095b32b9671358306b0339b4c06e7cbd8cb82505941fba30d1eb5b82f00;\n\n    /// @dev Utilizes ERC-7201's namespaced storage pattern for isolated storage access. This method computes\n    /// the storage slot based on a predetermined location, ensuring collision-resistant storage for contract states.\n    /// @custom:storage-location ERC-7201 formula applied to \"biconomy.storage.Nexus\", facilitating unique\n    /// namespace identification and storage segregation, as detailed in the specification.\n    /// @return $ The proxy to the `AccountStorage` struct, providing a reference to the namespaced storage slot.\n    function _getAccountStorage() internal pure returns (AccountStorage storage $) {\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"},"contracts/interfaces/modules/IHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Hook Management Interface\n/// @notice Provides methods for pre-checks and post-checks of transactions to ensure conditions and state consistency.\n/// @dev Defines two critical lifecycle hooks in the transaction process: `preCheck` and `postCheck`.\n/// These methods facilitate validating conditions prior to execution and verifying state changes afterwards, respectively.\ninterface IHook is IModule {\n    /// @notice Performs checks before a transaction is executed, potentially modifying the transaction context.\n    /// @dev This method is called before the execution of a transaction to validate and possibly adjust execution context.\n    /// @param msgSender The original sender of the transaction.\n    /// @param msgValue The amount of wei sent with the call.\n    /// @param msgData The calldata of the transaction.\n    /// @return hookData Data that may be used or modified throughout the transaction lifecycle, passed to `postCheck`.\n    function preCheck(address msgSender, uint256 msgValue, bytes calldata msgData) external returns (bytes memory hookData);\n\n    /// @notice Performs checks after a transaction is executed to ensure state consistency and log results.\n    /// @dev This method is called after the execution of a transaction to verify and react to the execution outcome.\n    /// @param hookData Data returned from `preCheck`, containing execution context or modifications.\n    function postCheck(bytes calldata hookData) external;\n}\n"},"contracts/interfaces/modules/IExecutor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Nexus - IExecutor Interface\n/// @notice Defines the interface for Executor modules within the Nexus Smart Account framework, compliant with the ERC-7579 standard.\n/// @dev Extends IModule to include functionalities specific to execution modules.\n/// This interface is future-proof, allowing for expansion and integration of advanced features in subsequent versions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IExecutor is IModule {\n    // Future methods for execution management will be defined here to accommodate evolving requirements.\n}\n"},"contracts/interfaces/modules/IFallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Nexus - IFallback Interface\n/// @notice Defines the interface for Fallback modules within the Nexus Smart Account framework, compliant with the ERC-7579 standard.\n/// @dev Extends IModule to include functionalities specific to fallback modules.\n/// This interface is future-proof, allowing for expansion and integration of advanced features in subsequent versions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IFallback is IModule {\n    // Future methods for fallback management will be defined here to accommodate evolving blockchain technologies.\n}\n"},"contracts/interfaces/modules/IValidator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IValidator is IModule {\n    /// @notice Validates a user operation as per ERC-4337 standard requirements.\n    /// @dev Should ensure that the signature and nonce are verified correctly before the transaction is allowed to proceed.\n    /// The function returns a status code indicating validation success or failure.\n    /// @param userOp The user operation containing transaction details to be validated.\n    /// @param userOpHash The hash of the user operation data, used for verifying the signature.\n    /// @return status The result of the validation process, typically indicating success or the type of failure.\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external returns (uint256);\n\n    /// @notice Verifies a signature against a hash, using the sender's address as a contextual check.\n    /// @dev Used to confirm the validity of a signature against the specific conditions set by the sender.\n    /// @param sender The address from which the operation was initiated, adding an additional layer of validation against the signature.\n    /// @param hash The hash of the data signed.\n    /// @param data The signature data to validate.\n    /// @return magicValue A bytes4 value that corresponds to the ERC-1271 standard, indicating the validity of the signature.\n    function isValidSignatureWithSender(address sender, bytes32 hash, bytes calldata data) external view returns (bytes4);\n}\n"},"contracts/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/// @title ModeLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n/// encoding is used.\n///    Function Signature of execute function:\n///           function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n/// This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n/// context.\n/// NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n/// implement\n/// more complex execution modes may use the entire bytes32.\n///\n/// |--------------------------------------------------------------------|\n/// | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n/// |--------------------------------------------------------------------|\n/// | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n/// |--------------------------------------------------------------------|\n///\n/// CALLTYPE: 1 byte\n/// CallType is used to determine how the executeCalldata paramter of the execute function has to be\n/// decoded.\n/// It can be either single, batch or delegatecall. In the future different calls could be added.\n/// CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n///\n/// EXECTYPE: 1 byte\n/// ExecType is used to determine how the account should handle the execution.\n/// It can indicate if the execution should revert on failure or continue execution.\n/// In the future more execution modes may be added.\n/// Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n/// a batch fails, the entire batch is reverted\n///\n/// UNUSED: 4 bytes\n/// Unused bytes are reserved for future use.\n///\n/// ModeSelector: bytes4\n/// The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n/// their accounts.\n/// the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n/// this is to prevent collisions between different vendors, while allowing innovation and the\n/// development of new features without coordination between ERC-7579 implementing accounts\n///\n/// ModePayload: 22 bytes\n/// Mode payload is used to pass additional data to the smart account execution, this may be\n/// interpreted depending on the ModeSelector\n///\n/// ExecutionCallData: n bytes\n/// single, delegatecall or batch exec abi.encoded as bytes\n\n// Custom type for improved developer experience\ntype ExecutionMode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/// @dev ModeLib is a helper library to encode/decode ModeCodes\nlibrary ModeLib {\n    function decode(\n        ExecutionMode mode\n    ) internal pure returns (CallType _calltype, ExecType _execType, ModeSelector _modeSelector, ModePayload _modePayload) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function decodeBasic(ExecutionMode mode) internal pure returns (CallType _calltype, ExecType _execType) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n        }\n    }\n\n    function encode(CallType callType, ExecType execType, ModeSelector mode, ModePayload payload) internal pure returns (ExecutionMode) {\n        return ExecutionMode.wrap(bytes32(abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)));\n    }\n\n    function encodeSimpleBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTrySingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTryBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeCustom(CallType callType, ExecType execType) internal pure returns (ExecutionMode mode) {\n        mode = encode(callType, execType, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ExecutionMode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { _eqModeSelector as == } for ModeSelector global;\nusing { _eqCallType as == } for CallType global;\nusing { _uneqCallType as != } for CallType global;\nusing { _eqExecType as == } for ExecType global;\n\nfunction _eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction _uneqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction _eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\n//slither-disable-next-line dead-code\nfunction _eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"contracts/lib/ExecLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Execution } from \"../types/DataTypes.sol\";\n\n/// @title ExecutionLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// Helper Library for decoding Execution calldata\n/// malloc for memory allocation is bad for gas. use this assembly instead\nlibrary ExecLib {\n    error InvalidBatchCallData();\n\n    function get2771CallData(bytes calldata cd) internal view returns (bytes memory callData) {\n        /// @solidity memory-safe-assembly\n        (cd);\n        assembly {\n            // as per solidity docs\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            callData := allocate(add(calldatasize(), 0x20)) //allocate extra 0x20 to store length\n            mstore(callData, add(calldatasize(), 0x14)) //store length, extra 0x14 is for msg.sender address\n            calldatacopy(add(callData, 0x20), 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            let senderPtr := allocate(0x14)\n            mstore(senderPtr, shl(96, caller()))\n        }\n    }\n\n    function decodeBatch(bytes calldata callData) internal view returns (Execution[] calldata executionBatch) {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n         * 0x4                  | -                 | abi.encode(IERC7579Execution.Execution[])\n         */\n        assembly (\"memory-safe\") {\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }   \n\n    function encodeBatch(Execution[] memory executions) internal pure returns (bytes memory callData) {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata) internal pure returns (address target, uint256 value, bytes calldata callData) {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function decodeDelegateCall(bytes calldata executionCalldata) internal pure returns (address delegate, bytes calldata callData) {\n        // destructure executionCallData according to single exec\n        delegate = address(uint160(bytes20(executionCalldata[0:20])));\n        callData = executionCalldata[20:];\n    }\n\n    function encodeSingle(address target, uint256 value, bytes memory callData) internal pure returns (bytes memory userOpCalldata) {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"contracts/lib/local/LocalCallDataParserLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\nlibrary LocalCallDataParserLib {\n    /// @dev Parses the `userOp.signature` to extract the module type, module initialization data,\n    ///      enable mode signature, and user operation signature. The `userOp.signature` must be\n    ///      encoded in a specific way to be parsed correctly.\n    /// @param packedData The packed signature data, typically coming from `userOp.signature`.\n    /// @return module The address of the module.\n    /// @return moduleType The type of module as a `uint256`.\n    /// @return moduleInitData Initialization data specific to the module.\n    /// @return enableModeSignature Signature used to enable the module mode.\n    /// @return userOpSignature The remaining user operation signature data.\n    function parseEnableModeData(\n        bytes calldata packedData\n    )\n        internal\n        pure\n        returns (\n            address module,\n            uint256 moduleType,\n            bytes calldata moduleInitData,\n            bytes calldata enableModeSignature,\n            bytes calldata userOpSignature\n        )\n    {\n        uint256 p;\n        assembly (\"memory-safe\") {\n            p := packedData.offset\n            module := shr(96, calldataload(p))\n\n            p := add(p, 0x14)\n            moduleType := calldataload(p)\n\n            moduleInitData.length := shr(224, calldataload(add(p, 0x20)))\n            moduleInitData.offset := add(p, 0x24)\n            p := add(moduleInitData.offset, moduleInitData.length)\n\n            enableModeSignature.length := shr(224, calldataload(p))\n            enableModeSignature.offset := add(p, 0x04)\n            p := sub(add(enableModeSignature.offset, enableModeSignature.length), packedData.offset)\n        }\n        userOpSignature = packedData[p:];\n    }\n\n    /// @dev Parses the data to obtain types and initdata's for Multi Type module install mode\n    /// @param initData Multi Type module init data, abi.encoded\n    function parseMultiTypeInitData(bytes calldata initData) internal pure returns (uint256[] calldata types, bytes[] calldata initDatas) {\n        // equivalent of:\n        // (types, initDatas) = abi.decode(initData,(uint[],bytes[]))\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            initDatas.offset := add(dataPointer, 32)\n            initDatas.length := calldataload(dataPointer)\n        }\n    }\n}\n"},"contracts/interfaces/base/IModuleManagerEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { CallType } from \"../../lib/ModeLib.sol\";\n\n/// @title ERC-7579 Module Manager Events and Errors Interface\n/// @notice Provides event and error definitions for actions related to module management in smart accounts.\n/// @dev Used by IModuleManager to define the events and errors associated with the installation and management of modules.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManagerEventsAndErrors {\n    /// @notice Emitted when a module is installed onto a smart account.\n    /// @param moduleTypeId The identifier for the type of module installed.\n    /// @param module The address of the installed module.\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Emitted when a module is uninstalled from a smart account.\n    /// @param moduleTypeId The identifier for the type of module uninstalled.\n    /// @param module The address of the uninstalled module.\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Thrown when attempting to remove the last validator.\n    error CanNotRemoveLastValidator();\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error ValidatorNotInstalled(address module);\n\n    /// @dev Thrown when there is no installed validator detected.\n    error NoValidatorInstalled();\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error InvalidModule(address module);\n\n    /// @dev Thrown when an invalid module type identifier is provided.\n    error InvalidModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a module that is already installed.\n    error ModuleAlreadyInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when an operation is performed by an unauthorized operator.\n    error UnauthorizedOperation(address operator);\n\n    /// @dev Thrown when there is an attempt to uninstall a module that is not installed.\n    error ModuleNotInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when a module address is set to zero.\n    error ModuleAddressCanNotBeZero();\n\n    /// @dev Thrown when a post-check fails after hook execution.\n    error HookPostCheckFailed();\n\n    /// @dev Thrown when there is an attempt to install a hook while another is already installed.\n    error HookAlreadyInstalled(address currentHook);\n\n    /// @dev Thrown when there is an attempt to install a fallback handler for a selector already having one.\n    error FallbackAlreadyInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when there is an attempt to uninstall a fallback handler for a selector that does not have one installed.\n    error FallbackNotInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when a fallback handler fails to uninstall properly.\n    error FallbackHandlerUninstallFailed();\n\n    /// @dev Thrown when no fallback handler is available for a given selector.\n    error MissingFallbackHandler(bytes4 selector);\n\n    /// @dev Thrown when Invalid data is provided for MultiType install flow\n    error InvalidInput();\n\n    /// @dev Thrown when unable to validate Module Enable Mode signature\n    error EnableModeSigError();\n\n    /// Error thrown when account installs/uninstalls module with mismatched input `moduleTypeId`\n    error MismatchModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a forbidden selector as a fallback handler.\n    error FallbackSelectorForbidden();\n\n    /// @dev Thrown when there is an attempt to install a fallback handler with an invalid calltype for a given selector.\n    error FallbackCallTypeInvalid();\n\n    /// @notice Error thrown when an execution with an unsupported CallType was made.\n    /// @param callType The unsupported call type.\n    error UnsupportedCallType(CallType callType);\n}\n"},"contracts/types/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n// Magic value for ERC-1271 valid signature\nbytes4 constant ERC1271_MAGICVALUE = 0x1626ba7e;\n\n// Value indicating an invalid ERC-1271 signature\nbytes4 constant ERC1271_INVALID = 0xFFFFFFFF;\n\n// Value indicating successful validation\nuint256 constant VALIDATION_SUCCESS = 0;\n\n// Value indicating failed validation\nuint256 constant VALIDATION_FAILED = 1;\n\n// Module type identifier for Multitype install\nuint256 constant MODULE_TYPE_MULTI = 0;\n\n// Module type identifier for validators\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\n\n// Module type identifier for executors\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\n\n// Module type identifier for fallback handlers\nuint256 constant MODULE_TYPE_FALLBACK = 3;\n\n// Module type identifier for hooks\nuint256 constant MODULE_TYPE_HOOK = 4;\n\nstring constant MODULE_ENABLE_MODE_NOTATION = \"ModuleEnableMode(address module,uint256 moduleType,bytes32 userOpHash,bytes32 initDataHash)\";\nbytes32 constant MODULE_ENABLE_MODE_TYPE_HASH = keccak256(bytes(MODULE_ENABLE_MODE_NOTATION));\n\n// Validation modes\nbytes1 constant MODE_VALIDATION = 0x00;\nbytes1 constant MODE_MODULE_ENABLE = 0x01;\n\nbytes4 constant SUPPORTS_ERC7739 = 0x77390000;\nbytes4 constant SUPPORTS_ERC7739_V1 = 0x77390001;"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\")`.\n    /// This is only used in `_hashTypedDataSansChainId`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID =\n        0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID.\n    /// We expect that most contracts will use `_hashTypedData` as the main hash,\n    /// and `_hashTypedDataSansChainId` only occasionally for cross-chain workflows.\n    /// Thus this is optimized for smaller bytecode size over runtime gas.\n    function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/excessively-safe-call/src/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"},"contracts/base/RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n/// @title RegistryAdapter\n/// @notice This contract provides an interface for interacting with an ERC-7484 compliant registry.\n/// @dev The registry feature is opt-in, allowing the smart account owner to select and trust specific attesters.\nabstract contract RegistryAdapter {\n    IERC7484 public registry;\n\n    /// @notice Emitted when a new ERC-7484 registry is configured for the account.\n    /// @param registry The configured registry contract.\n    event ERC7484RegistryConfigured(IERC7484 indexed registry);\n\n    /// @notice Modifier to check if a module meets the required attestations in the registry.\n    /// @param module The module to check.\n    /// @param moduleType The type of the module to verify in the registry.\n    modifier withRegistry(address module, uint256 moduleType) {\n        _checkRegistry(module, moduleType);\n        _;\n    }\n\n    /// @notice Configures the ERC-7484 registry and sets trusted attesters.\n    /// @param newRegistry The new registry contract to use.\n    /// @param attesters The list of attesters to trust.\n    /// @param threshold The number of attestations required.\n    function _configureRegistry(IERC7484 newRegistry, address[] calldata attesters, uint8 threshold) internal {\n        registry = newRegistry;\n        if (address(newRegistry) != address(0)) {\n            newRegistry.trustAttesters(threshold, attesters);\n        }\n        emit ERC7484RegistryConfigured(newRegistry);\n    }\n\n    /// @notice Checks the registry to ensure sufficient valid attestations for a module.\n    /// @param module The module to check.\n    /// @param moduleType The type of the module to verify in the registry.\n    /// @dev Reverts if the required attestations are not met.\n    function _checkRegistry(address module, uint256 moduleType) internal view {\n        IERC7484 moduleRegistry = registry;\n        if (address(moduleRegistry) != address(0)) {\n            // This will revert if attestations or the threshold are not met.\n            moduleRegistry.check(module, moduleType);\n        }\n    }\n}\n"},"contracts/interfaces/base/IStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\n\nimport { IHook } from \"../modules/IHook.sol\";\nimport { CallType } from \"../../lib/ModeLib.sol\";\n\n/// @title Nexus - IStorage Interface\n/// @notice Provides structured storage for Modular Smart Account under the Nexus suite, compliant with ERC-7579 and ERC-4337.\n/// @dev Manages structured storage using SentinelListLib for validators and executors, and a mapping for fallback handlers.\n/// This interface utilizes ERC-7201 storage location practices to ensure isolated and collision-resistant storage spaces within smart contracts.\n/// It is designed to support dynamic execution and modular management strategies essential for advanced smart account architectures.\n/// @custom:storage-location erc7201:biconomy.storage.Nexus\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IStorage {\n    /// @notice Struct storing validators and executors using Sentinel lists, and fallback handlers via mapping.\n    struct AccountStorage {\n        SentinelListLib.SentinelList validators; ///< List of validators, initialized upon contract deployment.\n        SentinelListLib.SentinelList executors; ///< List of executors, similarly initialized.\n        mapping(bytes4 => FallbackHandler) fallbacks; ///< Mapping of selectors to their respective fallback handlers.\n        IHook hook; ///< Current hook module associated with this account.\n        mapping(address hook => uint256) emergencyUninstallTimelock; ///< Mapping of hooks to requested timelocks.\n    }\n\n    /// @notice Defines a fallback handler with an associated handler address and a call type.\n    struct FallbackHandler {\n        address handler; ///< The address of the fallback function handler.\n        CallType calltype; ///< The type of call this handler supports (e.g., static or call).\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"contracts/types/DataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution\n/// @notice Struct to encapsulate execution data for a transaction\nstruct Execution {\n    /// @notice The target address for the transaction\n    address target;\n    /// @notice The value in wei to send with the transaction\n    uint256 value;\n    /// @notice The calldata for the transaction\n    bytes callData;\n}\n"}},"settings":{"remappings":["@openzeppelin/=node_modules/@openzeppelin/","forge-std/=node_modules/forge-std/src/","account-abstraction/=node_modules/account-abstraction/contracts/","solady/=node_modules/solady/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","sentinellist/=node_modules/sentinellist/src/","solarray/=node_modules/solarray/src/","erc7739Validator/=node_modules/erc7739-validator-base/src/","@ERC4337/=node_modules/@ERC4337/","@biconomy/=node_modules/@biconomy/","@erc7579/=node_modules/@erc7579/","@gnosis.pm/=node_modules/@gnosis.pm/","@prb/=node_modules/@prb/","@rhinestone/=node_modules/@rhinestone/","@safe-global/=node_modules/@safe-global/","@zerodev/=node_modules/@zerodev/","ExcessivelySafeCall/=node_modules/erc7739-validator-base/node_modules/excessively-safe-call/src/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/","ds-test/=node_modules/ds-test/","enumerableset4337/=node_modules/erc7739-validator-base/node_modules/@erc7579/enumerablemap4337/src/","erc4337-validation/=node_modules/erc7739-validator-base/node_modules/@rhinestone/erc4337-validation/src/","erc7579/=node_modules/erc7579/","erc7739-validator-base/=node_modules/erc7739-validator-base/","eth-gas-reporter/=node_modules/eth-gas-reporter/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","kernel/=node_modules/erc7739-validator-base/node_modules/@zerodev/kernel/src/","module-bases/=node_modules/erc7739-validator-base/node_modules/@rhinestone/module-bases/src/","modulekit/=node_modules/erc7739-validator-base/node_modules/@rhinestone/modulekit/src/","prep/=node_modules/prep/","safe7579/=node_modules/erc7739-validator-base/node_modules/@rhinestone/safe7579/src/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
