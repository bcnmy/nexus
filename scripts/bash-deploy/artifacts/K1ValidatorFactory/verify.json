{"language":"Solidity","sources":{"contracts/factory/K1ValidatorFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. For security issues, contact: security@biconomy.io\n\nimport { LibClone } from \"solady/utils/LibClone.sol\";\nimport { INexus } from \"../interfaces/INexus.sol\";\nimport { BootstrapLib } from \"../lib/BootstrapLib.sol\";\nimport { NexusBootstrap, BootstrapConfig } from \"../utils/NexusBootstrap.sol\";\nimport { Stakeable } from \"../common/Stakeable.sol\";\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n/// @title K1ValidatorFactory for Nexus Account\n/// @notice Manages the creation of Modular Smart Accounts compliant with ERC-7579 and ERC-4337 using a K1 validator.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract K1ValidatorFactory is Stakeable {\n    /// @notice Stores the implementation contract address used to create new Nexus instances.\n    /// @dev This address is set once upon deployment and cannot be changed afterwards.\n    address public immutable ACCOUNT_IMPLEMENTATION;\n\n    /// @notice Stores the K1 Validator module address.\n    /// @dev This address is set once upon deployment and cannot be changed afterwards.\n    address public immutable K1_VALIDATOR;\n\n    /// @notice Stores the Bootstrapper module address.\n    /// @dev This address is set once upon deployment and cannot be changed afterwards.\n    NexusBootstrap public immutable BOOTSTRAPPER;\n\n    IERC7484 public immutable REGISTRY;\n\n    /// @notice Emitted when a new Smart Account is created, capturing the account details and associated module configurations.\n    event AccountCreated(address indexed account, address indexed owner, uint256 indexed index);\n\n    /// @notice Error thrown when a zero address is provided for the implementation, K1 validator, or bootstrapper.\n    error ZeroAddressNotAllowed();\n\n    /// @notice Error thrown when an inner call fails.\n    error InnerCallFailed();\n\n    /// @notice Error thrown when the implementation code is empty.\n    error ImplementationCodeCanNotBeEmpty();\n\n    /// @notice Constructor to set the immutable variables.\n    /// @param implementation The address of the Nexus implementation to be used for all deployments.\n    /// @param factoryOwner The address of the factory owner.\n    /// @param k1Validator The address of the K1 Validator module to be used for all deployments.\n    /// @param bootstrapper The address of the Bootstrapper module to be used for all deployments.\n    constructor(\n        address implementation,\n        address factoryOwner,\n        address k1Validator,\n        NexusBootstrap bootstrapper,\n        IERC7484 registry\n    ) Stakeable(factoryOwner) {\n        require(\n            !(implementation == address(0) || k1Validator == address(0) || address(bootstrapper) == address(0) || factoryOwner == address(0)),\n            ZeroAddressNotAllowed()\n        );\n        require(implementation.code.length > 0, ImplementationCodeCanNotBeEmpty());\n        ACCOUNT_IMPLEMENTATION = implementation;\n        K1_VALIDATOR = k1Validator;\n        BOOTSTRAPPER = bootstrapper;\n        REGISTRY = registry;\n    }\n\n    /// @notice Creates a new Nexus with a specific validator and initialization data.\n    /// @param eoaOwner The address of the EOA owner of the Nexus.\n    /// @param index The index of the Nexus.\n    /// @param attesters The list of attesters for the Nexus.\n    /// @param threshold The threshold for the Nexus.\n    /// @return The address of the newly created Nexus.\n    function createAccount(\n        address eoaOwner,\n        uint256 index,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external payable returns (address payable) {\n        // Compute the actual salt for deterministic deployment\n        bytes32 actualSalt = keccak256(abi.encodePacked(eoaOwner, index, attesters, threshold));\n\n        // Deploy the Nexus contract using the computed salt\n        (bool alreadyDeployed, address account) = LibClone.createDeterministicERC1967(msg.value, ACCOUNT_IMPLEMENTATION, actualSalt);\n\n        // Create the validator configuration using the NexusBootstrap library\n        BootstrapConfig memory validator = BootstrapLib.createSingleConfig(K1_VALIDATOR, abi.encodePacked(eoaOwner));\n        bytes memory initData = BOOTSTRAPPER.getInitNexusWithSingleValidatorCalldata(validator, REGISTRY, attesters, threshold);\n\n        // Initialize the account if it was not already deployed\n        if (!alreadyDeployed) {\n            INexus(account).initializeAccount(initData);\n            emit AccountCreated(account, eoaOwner, index);\n        }\n        return payable(account);\n    }\n\n    /// @notice Computes the expected address of a Nexus contract using the factory's deterministic deployment algorithm.\n    /// @param eoaOwner The address of the EOA owner of the Nexus.\n    /// @param index The index of the Nexus.\n    /// @param attesters The list of attesters for the Nexus.\n    /// @param threshold The threshold for the Nexus.\n    /// @return expectedAddress The expected address at which the Nexus contract will be deployed if the provided parameters are used.\n    function computeAccountAddress(\n        address eoaOwner,\n        uint256 index,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (address payable expectedAddress) {\n        // Compute the actual salt for deterministic deployment\n        bytes32 actualSalt = keccak256(abi.encodePacked(eoaOwner, index, attesters, threshold));\n\n        // Predict the deterministic address using the LibClone library\n        expectedAddress = payable(LibClone.predictDeterministicAddressERC1967(ACCOUNT_IMPLEMENTATION, actualSalt, address(this)));\n    }\n}\n"},"node_modules/solady/src/utils/LibClone.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the ERC1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the ERC1167 pattern during runtime, and has the smallest bytecode.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here is does NOT append the immutable args into the calldata\n/// passed into delegatecall. It is simply an ERC1167 minimal proxy with the immutable arguments\n/// appended to the back of the runtime bytecode.\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal ERC1967 proxy with immutable args:\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n/// - Automatically verified on Etherscan.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\n///\n/// @dev ERC1967I proxy with immutable args:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n///\n/// @dev Minimal ERC1967 beacon proxy:\n/// A minimal beacon proxy, intended to be upgraded with an upgradable beacon.\n/// - Automatically verified on Etherscan.\n///\n/// @dev Minimal ERC1967 beacon proxy with immutable args:\n/// - Uses the identity precompile (0x4) to copy args during deployment.\n/// - Automatically verified on Etherscan.\n///\n/// @dev ERC1967I beacon proxy:\n/// An variant of the minimal ERC1967 beacon proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\n///\n/// @dev ERC1967I proxy with immutable args:\n/// An variant of the minimal ERC1967 beacon proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// - Uses the identity precompile (0x4) to copy args during deployment.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The keccak256 of deployed code for the clone proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant CLONE_CODE_HASH =\n        0x48db2cfdb2853fce0b464f1f93a1996469459df3ab6c812106074c4106a1eb1f;\n\n    /// @dev The keccak256 of deployed code for the PUSH0 proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant PUSH0_CLONE_CODE_HASH =\n        0x67bc6bde1b84d66e267c718ba44cf3928a615d29885537955cb43d44b3e789dc;\n\n    /// @dev The keccak256 of deployed code for the ERC-1167 CWIA proxy,\n    /// with the implementation set to `address(0)`.\n    bytes32 internal constant CWIA_CODE_HASH =\n        0x3cf92464268225a4513da40a34d967354684c32cd0edd67b5f668dfe3550e940;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967I_BEACON_PROXY_CODE_HASH =\n        0xf8c46d2793d5aa984eb827aeaba4b63aedcab80119212fce827309788735519a;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(c, 0x35) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the clone of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(c, 0x26), implementation) // 20\n            mstore(add(c, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(c, 0x36) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the PUSH0 clone of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `args`.\n    function clone(address implementation, bytes memory args) internal returns (address instance) {\n        instance = clone(0, implementation, args);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `args`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                        |\n             * ---------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                        |\n             * ---------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                               |\n             * 3d         | RETURNDATASIZE    | 0 r       |                               |\n             * 81         | DUP2              | r 0 r     |                               |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                               |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                               |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code    |\n             * f3         | RETURN            |           | [0..runSize): runtime code    |\n             * ---------------------------------------------------------------------------|\n             * RUNTIME (45 bytes + extraLength)                                           |\n             * ---------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                  | Memory                |\n             * ---------------------------------------------------------------------------|\n             *                                                                            |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                    |                       |\n             * 3d       | RETURNDATASIZE | 0 cds                  |                       |\n             * 3d       | RETURNDATASIZE | 0 0 cds                |                       |\n             * 37       | CALLDATACOPY   |                        | [0..cds): calldata    |\n             *                                                                            |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                      | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0                    | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0 0                  | [0..cds): calldata    |\n             * 36       | CALLDATASIZE   | cds 0 0 0              | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr  | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a       | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4       | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                            |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0          | [0..cds): calldata    |\n             * 82       | DUP3           | 0 rds success 0         | [0..cds): calldata   |\n             * 80       | DUP1           | 0 0 rds success 0      | [0..cds): calldata    |\n             * 3e       | RETURNDATACOPY | success 0              | [0..rds): returndata  |\n             * 90       | SWAP1          | 0 success              | [0..rds): returndata  |\n             * 3d       | RETURNDATASIZE | rds 0 success          | [0..rds): returndata  |\n             * 91       | SWAP2          | success 0 rds          | [0..rds): returndata  |\n             *                                                                            |\n             * 60 0x2b  | PUSH1 0x2b     | 0x2b success 0 rds     | [0..rds): returndata  |\n             * 57       | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                            |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                        | [0..rds): returndata  |\n             *                                                                            |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3       | RETURN         |                        | [0..rds): returndata  |\n             * ---------------------------------------------------------------------------+\n             */\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    function cloneDeterministic(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create2(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    /// This method does not revert if the clone has already been deployed.\n    function createDeterministicClone(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicClone(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `args` and `salt`.\n    /// This method does not revert if the clone has already been deployed.\n    function createDeterministicClone(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            // forgefmt: disable-next-item\n            mstore(add(m, gt(n, 0xffd2)), add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x0c), add(n, 0x37)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x0c), add(n, 0x37), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`\n    /// using immutable arguments encoded in `args`.\n    function initCode(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x57), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            mstore(c, add(0x37, n)) // Store the length.\n            mstore(add(c, add(n, 0x57)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0x77))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `args`.\n    function initCodeHash(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x43), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            hash := keccak256(add(m, 0x0c), add(n, 0x37))\n        }\n    }\n\n    /// @dev Returns the address of the clone of\n    /// `implementation` using immutable arguments encoded in `args`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnClone(instance, 0, 2 ** 256 - 1)`.\n    function argsOnClone(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x2d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x2d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnClone(instance, start, 2 ** 256 - 1)`.\n    function argsOnClone(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x2d))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x0d), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the clone with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnClone(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x0d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x2d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x60), 0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300)\n            mstore(add(c, 0x40), 0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc)\n            mstore(add(c, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(c, 0x09), 0x603d3d8160223d3973)\n            mstore(c, 0x5f) // Store the length.\n            mstore(0x40, add(c, 0x80)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 proxy of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*    MINIMAL ERC1967 PROXY WITH IMMUTABLE ARGS OPERATIONS    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation` and `args`.\n    function deployERC1967(address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967(0, implementation, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation` and `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create(value, m, add(n, 0x60))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create2(value, m, add(n, 0x60), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, args, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x60)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(n, 0x60), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation` and `args`.\n    function initCodeERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x80), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x60), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(c, 0x40), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(add(c, 0x20), 0x6009)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x60)) // Store the length.\n            mstore(add(c, add(n, 0x80)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xa0))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation` and `args`.\n    function initCodeHashERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x60), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(n, 0x60))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 proxy of `implementation`, `args`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x3d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x3d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x3d))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x1d), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x1d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x3d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                 ERC1967I PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I proxy of `implementation`.\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x54), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1d), implementation)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I proxy of `implementation`.\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I proxy of `implementation`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*       ERC1967I PROXY WITH IMMUTABLE ARGS OPERATIONS        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation` and `args`.\n    function deployERC1967I(address implementation, bytes memory args) internal returns (address) {\n        return deployERC1967I(0, implementation, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation` and `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation`, `args`, and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, args, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation`, `args`, and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create2(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation`, `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, args, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation`, `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x75), n))\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(gt(n, 0xffad), add(0xfe6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(0x75, n), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I proxy of `implementation` and `args`.\n    function initCodeERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(c, 0x75), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x55), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x35), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x95)), 0)\n            mstore(c, add(0x75, n)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I proxy of `implementation` and `args.\n    function initCodeHashERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x75), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(0x75, n))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I proxy of `implementation`, `args` with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967I(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967I(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967I(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967I(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x32), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967I(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                ERC1967 BOOTSTRAP OPERATIONS                */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A bootstrap is a minimal UUPS implementation that allows an ERC1967 proxy\n    // pointing to it to be upgraded. The ERC1967 proxy can then be deployed to a\n    // deterministic address independent of the implementation:\n    // ```\n    //     address bootstrap = LibClone.erc1967Bootstrap();\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\n    //     LibClone.bootstrapERC1967(bootstrap, implementation);\n    // ```\n\n    /// @dev Deploys the ERC1967 bootstrap if it has not been deployed.\n    function erc1967Bootstrap() internal returns (address) {\n        return erc1967Bootstrap(address(this));\n    }\n\n    /// @dev Deploys the ERC1967 bootstrap if it has not been deployed.\n    function erc1967Bootstrap(address authorizedUpgrader) internal returns (address bootstrap) {\n        bytes memory c = initCodeERC1967Bootstrap(authorizedUpgrader);\n        bootstrap = predictDeterministicAddress(keccak256(c), bytes32(0), address(this));\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                if iszero(create2(0, add(c, 0x20), mload(c), 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Replaces the implementation at `instance`.\n    function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, implementation)\n            if iszero(call(gas(), instance, 0, 0x0c, 0x14, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Replaces the implementation at `instance`, and then call it with `data`.\n    function bootstrapERC1967AndCall(address instance, address implementation, bytes memory data)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(data, implementation)\n            if iszero(call(gas(), instance, 0, add(data, 0x0c), add(n, 0x14), codesize(), 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function predictDeterministicAddressERC1967Bootstrap() internal view returns (address) {\n        return predictDeterministicAddressERC1967Bootstrap(address(this), address(this));\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function predictDeterministicAddressERC1967Bootstrap(\n        address authorizedUpgrader,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 hash = initCodeHashERC1967Bootstrap(authorizedUpgrader);\n        return predictDeterministicAddress(hash, bytes32(0), deployer);\n    }\n\n    /// @dev Returns the initialization code of the ERC1967 bootstrap.\n    function initCodeERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x80), 0x3d3560601c5af46047573d6000383e3d38fd0000000000000000000000000000)\n            mstore(add(c, 0x60), 0xa920a3ca505d382bbc55601436116049575b005b363d3d373d3d601436036014)\n            mstore(add(c, 0x40), 0x0338573d3560601c7f360894a13ba1a3210667c828492db98dca3e2076cc3735)\n            mstore(add(c, 0x20), authorizedUpgrader)\n            mstore(add(c, 0x0c), 0x606880600a3d393df3fe3373)\n            mstore(c, 0x72)\n            mstore(0x40, add(c, 0xa0))\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967 bootstrap.\n    function initCodeHashERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(initCodeERC1967Bootstrap(authorizedUpgrader));\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967BeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * 50            | POP              |                             | impl            |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x54), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 beacon proxy, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*    ERC1967 BEACON PROXY WITH IMMUTABLE ARGS OPERATIONS     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy with `args`.\n    function deployERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967BeaconProxy(0, beacon, args);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy with `args`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x75))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x75), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x55), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x35), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x75)) // Store the length.\n            mstore(add(c, add(n, 0x95)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy with `args`.\n    function initCodeHashERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x8b), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            mstore(m, add(0x6100523d8160233d3973, shl(56, n)))\n            hash := keccak256(add(m, 0x16), add(n, 0x75))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967 beacon proxy with `args`, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967BeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967BeaconProxy(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967BeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967BeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x32), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967 beacon proxy with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967BeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              ERC1967I BEACON PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967_BEACON_PROXY_CODE_HASH`.\n    //\n    // If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a ERC1967I beacon proxy.\n    function deployERC1967IBeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967IBeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a ERC1967I beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967IBeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (87 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * ~~~~~~ check calldatasize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds succ                    |                 |\n             * 14            | EQ               |                             | impl            |\n             * 60 0x52       | PUSH1 0x52       |                             | impl            |\n             * 57            | JUMPI            |                             | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 60 0x01    | PUSH1 0x01     | 1 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52    | PUSH1 0x52     | dest succ        | [1..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * fd         | REVERT         |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [1..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * f3         | RETURN         |                  | [1..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x07, 0x79)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `salt`.\n    function deployDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x07, 0x79, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x07, 0x79))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x07, 0x79, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I beacon proxy.\n    function initCodeERC1967IBeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x79), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x59), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x39), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60573d8160223d3973)\n            mstore(add(c, 0x99), 0)\n            mstore(c, 0x79) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I beacon proxy.\n    function initCodeHashERC1967IBeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x07, 0x79)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I beacon proxy, with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*    ERC1967I BEACON PROXY WITH IMMUTABLE ARGS OPERATIONS    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a ERC1967I beacon proxy with `args.\n    function deployERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967IBeaconProxy(0, beacon, args);\n    }\n\n    /// @dev Deploys a ERC1967I beacon proxy with `args.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x7a))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    function deployDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I beacon proxy with `args` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x7a)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the ERC1967I beacon proxy with `args`.\n    function initCodeERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x9a), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x7a), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x5a), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x3a), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100573d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x9a)), 0)\n            mstore(c, add(n, 0x7a)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xba))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the ERC1967I beacon proxy with `args`.\n    function initCodeHashERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x90), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x14), beacon)\n            mstore(c, add(0x6100573d8160233d3973, shl(56, n)))\n            hash := keccak256(add(c, 0x16), add(n, 0x7a))\n        }\n    }\n\n    /// @dev Returns the address of the ERC1967I beacon proxy, with  `args` and salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /// @dev Equivalent to `argsOnERC1967IBeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967IBeaconProxy(address instance)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x57))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x57, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `argsOnERC1967IBeaconProxy(instance, start, 2 ** 256 - 1)`.\n    function argsOnERC1967IBeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x57))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, args, add(start, 0x37), add(l, 0x40))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the immutable arguments on `instance` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `instance` MUST be deployed via the ERC1967I beacon proxy with immutable args functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `instance` does not have any code.\n    function argsOnERC1967IBeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x37), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x57)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns `address(0)` if the implementation address cannot be determined.\n    function implementationOf(address instance) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { extcodecopy(instance, 0x00, 0x00, 0x57) } 1 {} {\n                if mload(0x2d) {\n                    // ERC1967I and ERC1967IBeaconProxy detection.\n                    if or(\n                        eq(keccak256(0x00, 0x52), ERC1967I_CODE_HASH),\n                        eq(keccak256(0x00, 0x57), ERC1967I_BEACON_PROXY_CODE_HASH)\n                    ) {\n                        pop(staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20))\n                        result := mload(0x0c)\n                        break\n                    }\n                }\n                // 0age clone detection.\n                result := mload(0x0b)\n                codecopy(0x0b, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2c), CLONE_CODE_HASH)) { break }\n                mstore(0x0b, result) // Restore the zeroized memory.\n                // CWIA detection.\n                result := mload(0x0a)\n                codecopy(0x0a, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2d), CWIA_CODE_HASH)) { break }\n                mstore(0x0a, result) // Restore the zeroized memory.\n                // PUSH0 clone detection.\n                result := mload(0x09)\n                codecopy(0x09, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                result := shr(xor(keccak256(0x00, 0x2d), PUSH0_CLONE_CODE_HASH), result)\n                break\n            }\n            result := shr(96, result)\n            mstore(0x37, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns the `bytes32` at `offset` in `args`, without any bounds checks.\n    /// To load an address, you can use `address(bytes20(argLoad(args, offset)))`.\n    function argLoad(bytes memory args, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(args, 0x20), offset))\n        }\n    }\n}\n"},"contracts/interfaces/INexus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IERC4337Account } from \"./IERC4337Account.sol\";\nimport { IERC7579Account } from \"./IERC7579Account.sol\";\nimport { INexusEventsAndErrors } from \"./INexusEventsAndErrors.sol\";\n\n/// @title Nexus - INexus Interface\n/// @notice Integrates ERC-4337 and ERC-7579 standards to manage smart accounts within the Nexus suite.\n/// @dev Consolidates ERC-4337 user operations and ERC-7579 configurations into a unified interface for smart account management.\n/// It extends both IERC4337Account and IERC7579Account, enhancing modular capabilities and supporting advanced contract architectures.\n/// Includes error definitions for robust handling of common issues such as unsupported module types and execution failures.\n/// The initialize function sets up the account with validators and configurations, ensuring readiness for use.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface INexus is IERC4337Account, IERC7579Account, INexusEventsAndErrors {\n    /// @notice Initializes the smart account with a validator and custom data.\n    /// @dev This method sets up the account for operation, linking it with a validator and initializing it with specific data.\n    /// Can be called directly or via a factory.\n    /// @param initData Encoded data used for the account's configuration during initialization.\n    function initializeAccount(bytes calldata initData) external payable;\n}\n"},"contracts/lib/BootstrapLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { BootstrapConfig } from \"../utils/NexusBootstrap.sol\";\n\n/// @title NexusBootstrap Configuration Library\n/// @notice Provides utility functions to create and manage BootstrapConfig structures.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nlibrary BootstrapLib {\n    /// @notice Creates a single BootstrapConfig structure.\n    /// @param module The address of the module.\n    /// @param data The initialization data for the module.\n    /// @return config A BootstrapConfig structure containing the module and its data.\n    function createSingleConfig(address module, bytes memory data) internal pure returns (BootstrapConfig memory config) {\n        config.module = module;\n        config.data = data;\n    }\n\n    /// @notice Creates an array with a single BootstrapConfig structure.\n    /// @param module The address of the module.\n    /// @param data The initialization data for the module.\n    /// @return config An array containing a single BootstrapConfig structure.\n    function createArrayConfig(address module, bytes memory data) internal pure returns (BootstrapConfig[] memory config) {\n        config = new BootstrapConfig[](1);\n        config[0].module = module;\n        config[0].data = data;\n    }\n\n    /// @notice Creates an array of BootstrapConfig structures.\n    /// @param modules An array of module addresses.\n    /// @param datas An array of initialization data for each module.\n    /// @return configs An array of BootstrapConfig structures.\n    function createMultipleConfigs(address[] memory modules, bytes[] memory datas) internal pure returns (BootstrapConfig[] memory configs) {\n        require(modules.length == datas.length, \"BootstrapLib: length mismatch\");\n        configs = new BootstrapConfig[](modules.length);\n\n        for (uint256 i = 0; i < modules.length; i++) {\n            configs[i] = createSingleConfig(modules[i], datas[i]);\n        }\n    }\n}\n"},"contracts/utils/NexusBootstrap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. For security issues, contact: security@biconomy.io\n\nimport { ModuleManager } from \"../base/ModuleManager.sol\";\nimport { IModule } from \"../interfaces/modules/IModule.sol\";\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n/// @title NexusBootstrap Configuration for Nexus\n/// @notice Provides configuration and initialization for Nexus smart accounts.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nstruct BootstrapConfig {\n    address module;\n    bytes data;\n}\n\n/// @title NexusBootstrap\n/// @notice Manages the installation of modules into Nexus smart accounts using delegatecalls.\ncontract NexusBootstrap is ModuleManager {\n    /// @notice Initializes the Nexus account with a single validator.\n    /// @dev Intended to be called by the Nexus with a delegatecall.\n    /// @param validator The address of the validator module.\n    /// @param data The initialization data for the validator module.\n    function initNexusWithSingleValidator(\n        IModule validator,\n        bytes calldata data,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external {\n        _configureRegistry(registry, attesters, threshold);\n        _installValidator(address(validator), data);\n    }\n\n    /// @notice Initializes the Nexus account with multiple modules.\n    /// @dev Intended to be called by the Nexus with a delegatecall.\n    /// @param validators The configuration array for validator modules.\n    /// @param executors The configuration array for executor modules.\n    /// @param hook The configuration for the hook module.\n    /// @param fallbacks The configuration array for fallback handler modules.\n    function initNexus(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig[] calldata executors,\n        BootstrapConfig calldata hook,\n        BootstrapConfig[] calldata fallbacks,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external {\n        _configureRegistry(registry, attesters, threshold);\n\n        // Initialize validators\n        for (uint256 i = 0; i < validators.length; i++) {\n            _installValidator(validators[i].module, validators[i].data);\n        }\n\n        // Initialize executors\n        for (uint256 i = 0; i < executors.length; i++) {\n            if (executors[i].module == address(0)) continue;\n            _installExecutor(executors[i].module, executors[i].data);\n        }\n\n        // Initialize hook\n        if (hook.module != address(0)) {\n            _installHook(hook.module, hook.data);\n        }\n\n        // Initialize fallback handlers\n        for (uint256 i = 0; i < fallbacks.length; i++) {\n            if (fallbacks[i].module == address(0)) continue;\n            _installFallbackHandler(fallbacks[i].module, fallbacks[i].data);\n        }\n    }\n\n    /// @notice Initializes the Nexus account with a scoped set of modules.\n    /// @dev Intended to be called by the Nexus with a delegatecall.\n    /// @param validators The configuration array for validator modules.\n    /// @param hook The configuration for the hook module.\n    function initNexusScoped(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig calldata hook,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external {\n        _configureRegistry(registry, attesters, threshold);\n\n        // Initialize validators\n        for (uint256 i = 0; i < validators.length; i++) {\n            _installValidator(validators[i].module, validators[i].data);\n        }\n\n        // Initialize hook\n        if (hook.module != address(0)) {\n            _installHook(hook.module, hook.data);\n        }\n    }\n\n    /// @notice Prepares calldata for the initNexus function.\n    /// @param validators The configuration array for validator modules.\n    /// @param executors The configuration array for executor modules.\n    /// @param hook The configuration for the hook module.\n    /// @param fallbacks The configuration array for fallback handler modules.\n    /// @return init The prepared calldata for initNexus.\n    function getInitNexusCalldata(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig[] calldata executors,\n        BootstrapConfig calldata hook,\n        BootstrapConfig[] calldata fallbacks,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (bytes memory init) {\n        init = abi.encode(address(this), abi.encodeCall(this.initNexus, (validators, executors, hook, fallbacks, registry, attesters, threshold)));\n    }\n\n    /// @notice Prepares calldata for the initNexusScoped function.\n    /// @param validators The configuration array for validator modules.\n    /// @param hook The configuration for the hook module.\n    /// @return init The prepared calldata for initNexusScoped.\n    function getInitNexusScopedCalldata(\n        BootstrapConfig[] calldata validators,\n        BootstrapConfig calldata hook,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (bytes memory init) {\n        init = abi.encode(address(this), abi.encodeCall(this.initNexusScoped, (validators, hook, registry, attesters, threshold)));\n    }\n\n    /// @notice Prepares calldata for the initNexusWithSingleValidator function.\n    /// @param validator The configuration for the validator module.\n    /// @return init The prepared calldata for initNexusWithSingleValidator.\n    function getInitNexusWithSingleValidatorCalldata(\n        BootstrapConfig calldata validator,\n        IERC7484 registry,\n        address[] calldata attesters,\n        uint8 threshold\n    ) external view returns (bytes memory init) {\n        init = abi.encode(\n            address(this),\n            abi.encodeCall(this.initNexusWithSingleValidator, (IModule(validator.module), validator.data, registry, attesters, threshold))\n        );\n    }\n\n    /// @dev EIP712 domain name and version.\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        name = \"NexusBootstrap\";\n        version = \"1.0.0\";\n    }\n}\n"},"contracts/common/Stakeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. For security issues, contact: security@biconomy.io\n\nimport { Ownable } from \"solady/auth/Ownable.sol\";\nimport { IEntryPoint } from \"account-abstraction/interfaces/IEntryPoint.sol\";\n\nimport { IStakeable } from \"../interfaces/common/IStakeable.sol\";\n\n/// @title Stakeable Entity\n/// @notice Provides functionality to stake, unlock, and withdraw Ether on an EntryPoint.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Stakeable is Ownable, IStakeable {\n    /// @notice Error thrown when an invalid EntryPoint address is provided.\n    error InvalidEntryPointAddress();\n\n    constructor(address newOwner) {\n        _setOwner(newOwner);\n    }\n\n    /// @notice Stakes a certain amount of Ether on an EntryPoint.\n    /// @dev The contract should have enough Ether to cover the stake.\n    /// @param epAddress The address of the EntryPoint where the stake is added.\n    /// @param unstakeDelaySec The delay in seconds before the stake can be unlocked.\n    function addStake(address epAddress, uint32 unstakeDelaySec) external payable onlyOwner {\n        require(epAddress != address(0), InvalidEntryPointAddress());\n        IEntryPoint(epAddress).addStake{ value: msg.value }(unstakeDelaySec);\n    }\n\n    /// @notice Unlocks the stake on an EntryPoint.\n    /// @dev This starts the unstaking delay after which funds can be withdrawn.\n    /// @param epAddress The address of the EntryPoint from which the stake is to be unlocked.\n    function unlockStake(address epAddress) external onlyOwner {\n        require(epAddress != address(0), InvalidEntryPointAddress());\n        IEntryPoint(epAddress).unlockStake();\n    }\n\n    /// @notice Withdraws the stake from an EntryPoint to a specified address.\n    /// @dev This can only be done after the unstaking delay has passed since the unlock.\n    /// @param epAddress The address of the EntryPoint where the stake is withdrawn from.\n    /// @param withdrawAddress The address to receive the withdrawn stake.\n    function withdrawStake(address epAddress, address payable withdrawAddress) external onlyOwner {\n        require(epAddress != address(0), InvalidEntryPointAddress());\n        IEntryPoint(epAddress).withdrawStake(withdrawAddress);\n    }\n}\n"},"contracts/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IERC7484 {\n    event NewTrustedAttesters();\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(address smartAccount, address module, uint256 moduleType) external view;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(address module, uint256 moduleType, address[] calldata attesters, uint256 threshold) external view;\n}\n"},"contracts/interfaces/IERC4337Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title Nexus - IERC4337Account\n/// @notice This interface defines the necessary validation and execution methods for smart accounts under the ERC-4337 standard.\n/// @dev Provides a structure for implementing custom validation logic and execution methods that comply with ERC-4337 \"account abstraction\" specs.\n/// The validation method ensures proper signature and nonce verification before proceeding with transaction execution, critical for securing userOps.\n/// Also allows for the optional definition of an execution method to handle transactions post-validation, enhancing flexibility.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IERC4337Account {\n    /// Validate user's signature and nonce\n    /// the entryPoint will make the call to the recipient only if this validation call returns successfully.\n    /// signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n    /// This allows making a \"simulation call\" without a valid signature\n    /// Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n    ///\n    /// @dev ERC-4337-v-0.7 validation stage\n    /// @dev Must validate caller is the entryPoint.\n    ///      Must validate the signature and nonce\n    /// @param userOp              - The user operation that is about to be executed.\n    /// @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n    /// @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n    ///                              This is the minimum amount to transfer to the sender(entryPoint) to be\n    ///                              able to make the call. The excess is left as a deposit in the entrypoint\n    ///                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n    ///                              In case there is a paymaster in the request (or the current deposit is high\n    ///                              enough), this value will be zero.\n    /// @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n    ///                              `_unpackValidationData` to encode and decode.\n    ///                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n    ///                                 otherwise, an address of an \"authorizer\" contract.\n    ///                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n    ///                              <6-byte> validAfter - First timestamp this operation is valid\n    ///                                                    If an account doesn't use time-range, it is enough to\n    ///                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n    ///                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n\n    /// Account may implement this execute method.\n    /// passing this methodSig at the beginning of callData will cause the entryPoint to pass the\n    /// full UserOp (and hash)\n    /// to the account.\n    /// The account should skip the methodSig, and use the callData (and optionally, other UserOp\n    /// fields)\n    /// @dev ERC-4337-v-0.7 optional execution path\n    /// @param userOp              - The operation that was just validated.\n    /// @param userOpHash          - Hash of the user's request data.\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external payable;\n}\n"},"contracts/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IAccountConfig } from \"./base/IAccountConfig.sol\";\nimport { IExecutionHelper } from \"./base/IExecutionHelper.sol\";\nimport { IModuleManager } from \"./base/IModuleManager.sol\";\n\n/// @title Nexus - IERC7579Account\n/// @notice This interface integrates the functionalities required for a modular smart account compliant with ERC-7579 and ERC-4337 standards.\n/// @dev Combines configurations and operational management for smart accounts, bridging IAccountConfig, IExecutionHelper, and IModuleManager.\n/// Interfaces designed to support the comprehensive management of smart account operations including execution management and modular configurations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IERC7579Account is IAccountConfig, IExecutionHelper, IModuleManager {\n    /// @dev Validates a smart account signature according to ERC-1271 standards.\n    /// This method may delegate the call to a validator module to check the signature.\n    /// @param hash The hash of the data being validated.\n    /// @param data The signed data to validate.\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n}\n"},"contracts/interfaces/INexusEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title Nexus - INexus Events and Errors\n/// @notice Defines common errors for the Nexus smart account management interface.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface INexusEventsAndErrors {\n    /// @notice Emitted when a user operation is executed from `executeUserOp`\n    /// @param userOp The user operation that was executed.\n    /// @param innerCallRet The return data from the inner call execution.\n    event Executed(PackedUserOperation userOp, bytes innerCallRet);\n\n    /// @notice Error thrown when an unsupported ModuleType is requested.\n    /// @param moduleTypeId The ID of the unsupported module type.\n    error UnsupportedModuleType(uint256 moduleTypeId);\n\n    /// @notice Error thrown on failed execution.\n    error ExecutionFailed();\n\n    /// @notice Error thrown when the Factory fails to initialize the account with posted bootstrap data.\n    error NexusInitializationFailed();\n\n    /// @notice Error thrown when a zero address is provided as the Entry Point address.\n    error EntryPointCanNotBeZero();\n\n    /// @notice Error thrown when the provided implementation address is invalid.\n    error InvalidImplementationAddress();\n\n    /// @notice Error thrown when the provided implementation address is not a contract.\n    error ImplementationIsNotAContract();\n\n    /// @notice Error thrown when an inner call fails.\n    error InnerCallFailed();\n\n    /// @notice Error thrown when attempted to emergency-uninstall a hook\n    error EmergencyTimeLockNotExpired();\n}\n"},"contracts/base/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { IHook } from \"../interfaces/modules/IHook.sol\";\nimport { IModule } from \"../interfaces/modules/IModule.sol\";\nimport { IExecutor } from \"../interfaces/modules/IExecutor.sol\";\nimport { IFallback } from \"../interfaces/modules/IFallback.sol\";\nimport { IValidator } from \"../interfaces/modules/IValidator.sol\";\nimport { CallType, CALLTYPE_SINGLE, CALLTYPE_STATIC } from \"../lib/ModeLib.sol\";\nimport { ExecLib } from \"../lib/ExecLib.sol\";\nimport { LocalCallDataParserLib } from \"../lib/local/LocalCallDataParserLib.sol\";\nimport { IModuleManagerEventsAndErrors } from \"../interfaces/base/IModuleManagerEventsAndErrors.sol\";\nimport { MODULE_TYPE_VALIDATOR, MODULE_TYPE_EXECUTOR, MODULE_TYPE_FALLBACK, MODULE_TYPE_HOOK, MODULE_TYPE_MULTI, MODULE_ENABLE_MODE_TYPE_HASH, ERC1271_MAGICVALUE } from \"../types/Constants.sol\";\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/ExcessivelySafeCall.sol\";\nimport { RegistryAdapter } from \"./RegistryAdapter.sol\";\n\n/// @title Nexus - ModuleManager\n/// @notice Manages Validator, Executor, Hook, and Fallback modules within the Nexus suite, supporting\n/// @dev Implements SentinelList for managing modules via a linked list structure, adhering to ERC-7579.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nabstract contract ModuleManager is Storage, EIP712, IModuleManagerEventsAndErrors, RegistryAdapter {\n    using SentinelListLib for SentinelListLib.SentinelList;\n    using LocalCallDataParserLib for bytes;\n    using ExecLib for address;\n    using ExcessivelySafeCall for address;\n\n    /// @notice Ensures the message sender is a registered executor module.\n    modifier onlyExecutorModule() virtual {\n        require(_getAccountStorage().executors.contains(msg.sender), InvalidModule(msg.sender));\n        _;\n    }\n\n    /// @notice Does pre-checks and post-checks using an installed hook on the account.\n    /// @dev sender, msg.data and msg.value is passed to the hook to implement custom flows.\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            _;\n            IHook(hook).postCheck(hookData);\n        }\n    }\n\n    receive() external payable {}\n\n    /// @dev Fallback function to manage incoming calls using designated handlers based on the call type.\n    /// Hooked manually in the _fallback function\n    fallback() external payable {\n        _fallback(msg.data);\n    }\n\n    /// @dev Retrieves a paginated list of validator addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of validator modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of validator addresses to return.\n    /// @return array An array of validator addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getValidatorsPaginated(address cursor, uint256 size) external view returns (address[] memory array, address next) {\n        (array, next) = _paginate(_getAccountStorage().validators, cursor, size);\n    }\n\n    /// @dev Retrieves a paginated list of executor addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of executor modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of executor addresses to return.\n    /// @return array An array of executor addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getExecutorsPaginated(address cursor, uint256 size) external view returns (address[] memory array, address next) {\n        (array, next) = _paginate(_getAccountStorage().executors, cursor, size);\n    }\n\n    /// @notice Retrieves the currently active hook address.\n    /// @return hook The address of the active hook module.\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n\n    /// @notice Fetches the fallback handler for a specific selector.\n    /// @param selector The function selector to query.\n    /// @return calltype The type of call that the handler manages.\n    /// @return handler The address of the fallback handler.\n    function getFallbackHandlerBySelector(bytes4 selector) external view returns (CallType, address) {\n        FallbackHandler memory handler = _getAccountStorage().fallbacks[selector];\n        return (handler.calltype, handler.handler);\n    }\n\n    /// @dev Initializes the module manager by setting up default states for validators and executors.\n    function _initModuleManager() internal virtual {\n        // account module storage\n        AccountStorage storage ams = _getAccountStorage();\n        ams.executors.init();\n        ams.validators.init();\n    }\n\n    /// @dev Implements Module Enable Mode flow.\n    /// @param packedData Data source to parse data required to perform Module Enable mode from.\n    /// @return userOpSignature the clean signature which can be further used for userOp validation\n    function _enableMode(bytes32 userOpHash, bytes calldata packedData) internal returns (bytes calldata userOpSignature) {\n        address module;\n        uint256 moduleType;\n        bytes calldata moduleInitData;\n        bytes calldata enableModeSignature;\n\n        (module, moduleType, moduleInitData, enableModeSignature, userOpSignature) = packedData.parseEnableModeData();\n\n        if (!_checkEnableModeSignature(_getEnableModeDataHash(module, moduleType, userOpHash, moduleInitData), enableModeSignature))\n            revert EnableModeSigError();\n\n        _installModule(moduleType, module, moduleInitData);\n    }\n\n    /// @notice Installs a new module to the smart account.\n    /// @param moduleTypeId The type identifier of the module being installed, which determines its role:\n    /// - 0 for MultiType\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// @param module The address of the module to install.\n    /// @param initData Initialization data for the module.\n    /// @dev This function goes through hook checks via withHook modifier.\n    /// @dev No need to check that the module is already installed, as this check is done\n    /// when trying to sstore the module in an appropriate SentinelList\n    function _installModule(uint256 moduleTypeId, address module, bytes calldata initData) internal withHook {\n        if (module == address(0)) revert ModuleAddressCanNotBeZero();\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _installValidator(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _installExecutor(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _installFallbackHandler(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _installHook(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_MULTI) {\n            _multiTypeInstall(module, initData);\n        } else {\n            revert InvalidModuleTypeId(moduleTypeId);\n        }\n    }\n\n    /// @dev Installs a new validator module after checking if it matches the required module type.\n    /// @param validator The address of the validator module to be installed.\n    /// @param data Initialization data to configure the validator upon installation.\n    function _installValidator(address validator, bytes calldata data) internal virtual withRegistry(validator, MODULE_TYPE_VALIDATOR) {\n        if (!IValidator(validator).isModuleType(MODULE_TYPE_VALIDATOR)) revert MismatchModuleTypeId(MODULE_TYPE_VALIDATOR);\n        _getAccountStorage().validators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    /// @dev Uninstalls a validator module /!\\ ensuring the account retains at least one validator.\n    /// @param validator The address of the validator to be uninstalled.\n    /// @param data De-initialization data to configure the validator upon uninstallation.\n    function _uninstallValidator(address validator, bytes calldata data) internal virtual {\n        SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n\n        // Perform the removal first\n        validators.pop(prev, validator);\n\n        // Sentinel pointing to itself / zero means the list is empty / uninitialized, so check this after removal\n        // Below error is very specific to uninstalling validators.\n        require(_hasValidators(), CanNotRemoveLastValidator());\n        validator.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData));\n    }\n\n    /// @dev Installs a new executor module after checking if it matches the required module type.\n    /// @param executor The address of the executor module to be installed.\n    /// @param data Initialization data to configure the executor upon installation.\n    function _installExecutor(address executor, bytes calldata data) internal virtual withRegistry(executor, MODULE_TYPE_EXECUTOR) {\n        if (!IExecutor(executor).isModuleType(MODULE_TYPE_EXECUTOR)) revert MismatchModuleTypeId(MODULE_TYPE_EXECUTOR);\n        _getAccountStorage().executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    /// @dev Uninstalls an executor module by removing it from the executors list.\n    /// @param executor The address of the executor to be uninstalled.\n    /// @param data De-initialization data to configure the executor upon uninstallation.\n    function _uninstallExecutor(address executor, bytes calldata data) internal virtual {\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        _getAccountStorage().executors.pop(prev, executor);\n        executor.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData));\n    }\n\n    /// @dev Installs a hook module, ensuring no other hooks are installed before proceeding.\n    /// @param hook The address of the hook to be installed.\n    /// @param data Initialization data to configure the hook upon installation.\n    function _installHook(address hook, bytes calldata data) internal virtual withRegistry(hook, MODULE_TYPE_HOOK) {\n        if (!IHook(hook).isModuleType(MODULE_TYPE_HOOK)) revert MismatchModuleTypeId(MODULE_TYPE_HOOK);\n        address currentHook = _getHook();\n        require(currentHook == address(0), HookAlreadyInstalled(currentHook));\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    /// @dev Uninstalls a hook module, ensuring the current hook matches the one intended for uninstallation.\n    /// @param hook The address of the hook to be uninstalled.\n    /// @param data De-initialization data to configure the hook upon uninstallation.\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\n        _setHook(address(0));\n        hook.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data));\n    }\n\n    /// @dev Sets the current hook in the storage to the specified address.\n    /// @param hook The new hook address.\n    function _setHook(address hook) internal virtual {\n        _getAccountStorage().hook = IHook(hook);\n    }\n\n    /// @dev Installs a fallback handler for a given selector with initialization data.\n    /// @param handler The address of the fallback handler to install.\n    /// @param params The initialization parameters including the selector and call type.\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual withRegistry(handler, MODULE_TYPE_FALLBACK) {\n        if (!IFallback(handler).isModuleType(MODULE_TYPE_FALLBACK)) revert MismatchModuleTypeId(MODULE_TYPE_FALLBACK);\n        // Extract the function selector from the provided parameters.\n        bytes4 selector = bytes4(params[0:4]);\n\n        // Extract the call type from the provided parameters.\n        CallType calltype = CallType.wrap(bytes1(params[4]));\n\n        require(calltype == CALLTYPE_SINGLE || calltype == CALLTYPE_STATIC, FallbackCallTypeInvalid());\n\n        // Extract the initialization data from the provided parameters.\n        bytes memory initData = params[5:];\n\n        // Revert if the selector is either `onInstall(bytes)` (0x6d61fe70) or `onUninstall(bytes)` (0x8a91b0e3) or explicit bytes(0).\n        // These selectors are explicitly forbidden to prevent security vulnerabilities.\n        // Allowing these selectors would enable unauthorized users to uninstall and reinstall critical modules.\n        // If a validator module is uninstalled and reinstalled without proper authorization, it can compromise\n        // the account's security and integrity. By restricting these selectors, we ensure that the fallback handler\n        // cannot be manipulated to disrupt the expected behavior and security of the account.\n        require(!(selector == bytes4(0x6d61fe70) || selector == bytes4(0x8a91b0e3) || selector == bytes4(0)), FallbackSelectorForbidden());\n\n        // Revert if a fallback handler is already installed for the given selector.\n        // This check ensures that we do not overwrite an existing fallback handler, which could lead to unexpected behavior.\n        require(!_isFallbackHandlerInstalled(selector), FallbackAlreadyInstalledForSelector(selector));\n\n        // Store the fallback handler and its call type in the account storage.\n        // This maps the function selector to the specified fallback handler and call type.\n        _getAccountStorage().fallbacks[selector] = FallbackHandler(handler, calltype);\n\n        // Invoke the `onInstall` function of the fallback handler with the provided initialization data.\n        // This step allows the fallback handler to perform any necessary setup or initialization.\n        IFallback(handler).onInstall(initData);\n    }\n\n    /// @dev Uninstalls a fallback handler for a given selector.\n    /// @param fallbackHandler The address of the fallback handler to uninstall.\n    /// @param data The de-initialization data containing the selector.\n    function _uninstallFallbackHandler(address fallbackHandler, bytes calldata data) internal virtual {\n        _getAccountStorage().fallbacks[bytes4(data[0:4])] = FallbackHandler(address(0), CallType.wrap(0x00));\n        fallbackHandler.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data[4:]));\n    }\n\n    /// @notice Installs a module with multiple types in a single operation.\n    /// @dev This function handles installing a multi-type module by iterating through each type and initializing it.\n    /// The initData should include an ABI-encoded tuple of (uint[] types, bytes[] initDatas).\n    /// @param module The address of the multi-type module.\n    /// @param initData Initialization data for each type within the module.\n    function _multiTypeInstall(address module, bytes calldata initData) internal virtual {\n        (uint256[] calldata types, bytes[] calldata initDatas) = initData.parseMultiTypeInitData();\n\n        uint256 length = types.length;\n        if (initDatas.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 theType = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (theType == MODULE_TYPE_VALIDATOR) {\n                _installValidator(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_EXECUTOR) {\n                _installExecutor(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_FALLBACK) {\n                _installFallbackHandler(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK (global only, not sig-specific)      */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_HOOK) {\n                _installHook(module, initDatas[i]);\n            }\n        }\n    }\n\n    /// @notice Checks if an enable mode signature is valid.\n    /// @param structHash data hash.\n    /// @param sig Signature.\n    function _checkEnableModeSignature(bytes32 structHash, bytes calldata sig) internal view returns (bool) {\n        address enableModeSigValidator = address(bytes20(sig[0:20]));\n        if (!_isValidatorInstalled(enableModeSigValidator)) {\n            revert ValidatorNotInstalled(enableModeSigValidator);\n        }\n        bytes32 eip712Digest = _hashTypedData(structHash);\n\n        // Use standard IERC-1271/ERC-7739 interface.\n        // Even if the validator doesn't support 7739 under the hood, it is still secure,\n        // as eip712digest is already built based on 712Domain of this Smart Account\n        // This interface should always be exposed by validators as per ERC-7579\n        try IValidator(enableModeSigValidator).isValidSignatureWithSender(address(this), eip712Digest, sig[20:]) returns (bytes4 res) {\n            return res == ERC1271_MAGICVALUE;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Builds the enable mode data hash as per eip712\n    /// @param module Module being enabled\n    /// @param moduleType Type of the module as per EIP-7579\n    /// @param userOpHash Hash of the User Operation\n    /// @param initData Module init data.\n    /// @return structHash data hash\n    function _getEnableModeDataHash(address module, uint256 moduleType, bytes32 userOpHash, bytes calldata initData) internal view returns (bytes32) {\n        return keccak256(abi.encode(MODULE_ENABLE_MODE_TYPE_HASH, module, moduleType, userOpHash, keccak256(initData)));\n    }\n\n    /// @notice Checks if a module is installed on the smart account.\n    /// @param moduleTypeId The module type ID.\n    /// @param module The module address.\n    /// @param additionalContext Additional context for checking installation.\n    /// @return True if the module is installed, false otherwise.\n    function _isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) internal view returns (bool) {\n        additionalContext;\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            if (additionalContext.length >= 4) {\n                selector = bytes4(additionalContext[0:4]);\n            } else {\n                selector = bytes4(0x00000000);\n            }\n            return _isFallbackHandlerInstalled(selector, module);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev Checks if a fallback handler is set for a given selector.\n    /// @param selector The function selector to check.\n    /// @return True if a fallback handler is set, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector) internal view virtual returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler != address(0);\n    }\n\n    /// @dev Checks if the expected fallback handler is installed for a given selector.\n    /// @param selector The function selector to check.\n    /// @param expectedHandler The address of the handler expected to be installed.\n    /// @return True if the installed handler matches the expected handler, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector, address expectedHandler) internal view returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler == expectedHandler;\n    }\n\n    /// @dev Checks if a validator is currently installed.\n    /// @param validator The address of the validator to check.\n    /// @return True if the validator is installed, otherwise false.\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\n        return _getAccountStorage().validators.contains(validator);\n    }\n\n    /// @dev Checks if there is at least one validator installed.\n    /// @return True if there is at least one validator, otherwise false.\n    function _hasValidators() internal view returns (bool) {\n        return\n            _getAccountStorage().validators.getNext(address(0x01)) != address(0x01) &&\n            _getAccountStorage().validators.getNext(address(0x01)) != address(0x00);\n    }\n\n    /// @dev Checks if an executor is currently installed.\n    /// @param executor The address of the executor to check.\n    /// @return True if the executor is installed, otherwise false.\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\n        return _getAccountStorage().executors.contains(executor);\n    }\n\n    /// @dev Checks if a hook is currently installed.\n    /// @param hook The address of the hook to check.\n    /// @return True if the hook is installed, otherwise false.\n    function _isHookInstalled(address hook) internal view returns (bool) {\n        return _getHook() == hook;\n    }\n\n    /// @dev Retrieves the current hook from the storage.\n    /// @return hook The address of the current hook.\n    function _getHook() internal view returns (address hook) {\n        hook = address(_getAccountStorage().hook);\n    }\n\n    function _fallback(bytes calldata callData) private {\n        bool success;\n        bytes memory result;\n        FallbackHandler storage $fallbackHandler = _getAccountStorage().fallbacks[msg.sig];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n\n        if (handler != address(0)) {\n            // hook manually\n            address hook = _getHook();\n            bytes memory hookData;\n            if (hook != address(0)) {\n                hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            }\n            //if there's a fallback handler, call it\n            if (calltype == CALLTYPE_STATIC) {\n                (success, result) = handler.staticcall(ExecLib.get2771CallData(callData));\n            } else if (calltype == CALLTYPE_SINGLE) {\n                (success, result) = handler.call{ value: msg.value }(ExecLib.get2771CallData(callData));\n            } else {\n                revert UnsupportedCallType(calltype);\n            }\n\n            // Use revert message from fallback handler if the call was not successful\n            assembly {\n                if iszero(success) {\n                    revert(add(result, 0x20), mload(result))\n                }\n            }\n\n            // hook post check\n            if (hook != address(0)) {\n                IHook(hook).postCheck(hookData);\n            }\n\n            // return the result\n            assembly {\n                return(add(result, 0x20), mload(result))\n            }\n        }\n        \n        // If there's no handler, the call can be one of onERCXXXReceived()\n        // No need to hook this as no execution is done here\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        // if there was no handler and it is not the onERCXXXReceived call, revert\n        revert MissingFallbackHandler(msg.sig);\n    }\n\n    /// @dev Helper function to paginate entries in a SentinelList.\n    /// @param list The SentinelList to paginate.\n    /// @param cursor The cursor to start paginating from.\n    /// @param size The number of entries to return.\n    /// @return array The array of addresses in the list.\n    /// @return nextCursor The cursor for the next page of entries.\n    function _paginate(\n        SentinelListLib.SentinelList storage list,\n        address cursor,\n        uint256 size\n    ) private view returns (address[] memory array, address nextCursor) {\n        (array, nextCursor) = list.getEntriesPaginated(cursor, size);\n    }\n}\n"},"contracts/interfaces/modules/IModule.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Nexus - ERC-7579 Module Base Interface\n/// @notice Interface for module management in smart accounts, complying with ERC-7579 specifications.\n/// @dev Defines the lifecycle hooks and checks for modules within the smart account architecture.\n/// This interface includes methods for installing, uninstalling, and verifying module types and initialization status.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModule {\n    /// @notice Installs the module with necessary initialization data.\n    /// @dev Reverts if the module is already initialized.\n    /// @param data Arbitrary data required for initializing the module during `onInstall`.\n    function onInstall(bytes calldata data) external;\n\n    /// @notice Uninstalls the module and allows for cleanup via arbitrary data.\n    /// @dev Reverts if any issues occur that prevent clean uninstallation.\n    /// @param data Arbitrary data required for deinitializing the module during `onUninstall`.\n    function onUninstall(bytes calldata data) external;\n\n    /// @notice Determines if the module matches a specific module type.\n    /// @dev Should return true if the module corresponds to the type ID, false otherwise.\n    /// @param moduleTypeId Numeric ID of the module type as per ERC-7579 specifications.\n    /// @return True if the module is of the specified type, false otherwise.\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /// @notice Checks if the module has been initialized for a specific smart account.\n    /// @dev Returns true if initialized, false otherwise.\n    /// @param smartAccount Address of the smart account to check for initialization status.\n    /// @return True if the module is initialized for the given smart account, false otherwise.\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n"},"node_modules/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"contracts/interfaces/common/IStakeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. For security issues, contact: security@biconomy.io\n\n/// @title Stakeable Entity Interface\n/// @notice Interface for staking, unlocking, and withdrawing Ether on an EntryPoint.\n/// @dev Defines functions for managing stakes on an EntryPoint.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IStakeable {\n    /// @notice Stakes a certain amount of Ether on an EntryPoint.\n    /// @dev The contract should have enough Ether to cover the stake.\n    /// @param epAddress The address of the EntryPoint where the stake is added.\n    /// @param unstakeDelaySec The delay in seconds before the stake can be unlocked.\n    function addStake(address epAddress, uint32 unstakeDelaySec) external payable;\n\n    /// @notice Unlocks the stake on an EntryPoint.\n    /// @dev This starts the unstaking delay after which funds can be withdrawn.\n    /// @param epAddress The address of the EntryPoint from which the stake is to be unlocked.\n    function unlockStake(address epAddress) external;\n\n    /// @notice Withdraws the stake from an EntryPoint to a specified address.\n    /// @dev This can only be done after the unstaking delay has passed since the unlock.\n    /// @param epAddress The address of the EntryPoint where the stake is withdrawn from.\n    /// @param withdrawAddress The address to receive the withdrawn stake.\n    function withdrawStake(address epAddress, address payable withdrawAddress) external;\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"contracts/interfaces/base/IAccountConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { ExecutionMode } from \"../../lib/ModeLib.sol\";\n\n/// @title Nexus - ERC-7579 Account Configuration Interface\n/// @notice Interface for querying and verifying configurations of Smart Accounts compliant with ERC-7579.\n/// @dev Provides methods to check supported execution modes and module types for Smart Accounts, ensuring flexible and extensible configuration.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IAccountConfig {\n    /// @notice Returns the account ID in a structured format: \"vendorname.accountname.semver\"\n    /// @return accountImplementationId The account ID of the smart account\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /// @notice Checks if the account supports a certain execution mode.\n    /// @param encodedMode The encoded mode to verify.\n    /// @return supported True if the account supports the mode, false otherwise.\n    function supportsExecutionMode(ExecutionMode encodedMode) external view returns (bool supported);\n\n    /// @notice Checks if the account supports a specific module type.\n    /// @param moduleTypeId The module type ID to verify.\n    /// @return supported True if the account supports the module type, false otherwise.\n    function supportsModule(uint256 moduleTypeId) external view returns (bool supported);\n}\n"},"contracts/interfaces/base/IExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { ExecutionMode } from \"../../lib/ModeLib.sol\";\n\nimport { IExecutionHelperEventsAndErrors } from \"./IExecutionHelperEventsAndErrors.sol\";\n\n/// @title Nexus - IExecutionHelper\n/// @notice Interface for executing transactions on behalf of smart accounts within the Nexus system.\n/// @dev Extends functionality for transaction execution with error handling as defined in IExecutionHelperEventsAndErrors.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IExecutionHelper is IExecutionHelperEventsAndErrors {\n    /// @notice Executes a transaction with specified execution mode and calldata.\n    /// @param mode The execution mode, defining how the transaction is processed.\n    /// @param executionCalldata The calldata to execute.\n    /// @dev This function ensures that the execution complies with smart account execution policies and handles errors appropriately.\n    function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n\n    /// @notice Allows an executor module to perform transactions on behalf of the account.\n    /// @param mode The execution mode that details how the transaction should be handled.\n    /// @param executionCalldata The transaction data to be executed.\n    /// @return returnData The result of the execution, allowing for error handling and results interpretation by the executor module.\n    function executeFromExecutor(ExecutionMode mode, bytes calldata executionCalldata) external payable returns (bytes[] memory returnData);\n}\n"},"contracts/interfaces/base/IModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModuleManagerEventsAndErrors } from \"./IModuleManagerEventsAndErrors.sol\";\n\n/// @title Nexus - IModuleManager\n/// @notice Interface for managing modules within Smart Accounts, providing methods for installation and removal of modules.\n/// @dev Extends the IModuleManagerEventsAndErrors interface to include event and error definitions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManager is IModuleManagerEventsAndErrors {\n    /// @notice Installs a Module of a specific type onto the smart account.\n    /// @param moduleTypeId The identifier for the module type.\n    /// @param module The address of the module to be installed.\n    /// @param initData Initialization data for configuring the module upon installation.\n    function installModule(uint256 moduleTypeId, address module, bytes calldata initData) external payable;\n\n    /// @notice Uninstalls a Module of a specific type from the smart account.\n    /// @param moduleTypeId The identifier for the module type being uninstalled.\n    /// @param module The address of the module to uninstall.\n    /// @param deInitData De-initialization data for configuring the module upon uninstallation.\n    function uninstallModule(uint256 moduleTypeId, address module, bytes calldata deInitData) external payable;\n\n    /// @notice Checks if a specific module is installed on the smart account.\n    /// @param moduleTypeId The module type identifier to check.\n    /// @param module The address of the module.\n    /// @param additionalContext Additional information that may be required to verify the module's installation.\n    /// @return installed True if the module is installed, false otherwise.\n    function isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) external view returns (bool installed);\n}\n"},"node_modules/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"contracts/base/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IStorage } from \"../interfaces/base/IStorage.sol\";\n\n/// @title Nexus - Storage\n/// @notice Manages isolated storage spaces for Modular Smart Account in compliance with ERC-7201 standard to ensure collision-resistant storage.\n/// @dev Implements the ERC-7201 namespaced storage pattern to maintain secure and isolated storage sections for different states within Nexus suite.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Storage is IStorage {\n    /// @custom:storage-location erc7201:biconomy.storage.Nexus\n    /// ERC-7201 namespaced via `keccak256(abi.encode(uint256(keccak256(bytes(\"biconomy.storage.Nexus\"))) - 1)) & ~bytes32(uint256(0xff));`\n    bytes32 private constant _STORAGE_LOCATION = 0x0bb70095b32b9671358306b0339b4c06e7cbd8cb82505941fba30d1eb5b82f00;\n\n    /// @dev Utilizes ERC-7201's namespaced storage pattern for isolated storage access. This method computes\n    /// the storage slot based on a predetermined location, ensuring collision-resistant storage for contract states.\n    /// @custom:storage-location ERC-7201 formula applied to \"biconomy.storage.Nexus\", facilitating unique\n    /// namespace identification and storage segregation, as detailed in the specification.\n    /// @return $ The proxy to the `AccountStorage` struct, providing a reference to the namespaced storage slot.\n    function _getAccountStorage() internal pure returns (AccountStorage storage $) {\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"},"contracts/interfaces/modules/IHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Hook Management Interface\n/// @notice Provides methods for pre-checks and post-checks of transactions to ensure conditions and state consistency.\n/// @dev Defines two critical lifecycle hooks in the transaction process: `preCheck` and `postCheck`.\n/// These methods facilitate validating conditions prior to execution and verifying state changes afterwards, respectively.\ninterface IHook is IModule {\n    /// @notice Performs checks before a transaction is executed, potentially modifying the transaction context.\n    /// @dev This method is called before the execution of a transaction to validate and possibly adjust execution context.\n    /// @param msgSender The original sender of the transaction.\n    /// @param msgValue The amount of wei sent with the call.\n    /// @param msgData The calldata of the transaction.\n    /// @return hookData Data that may be used or modified throughout the transaction lifecycle, passed to `postCheck`.\n    function preCheck(address msgSender, uint256 msgValue, bytes calldata msgData) external returns (bytes memory hookData);\n\n    /// @notice Performs checks after a transaction is executed to ensure state consistency and log results.\n    /// @dev This method is called after the execution of a transaction to verify and react to the execution outcome.\n    /// @param hookData Data returned from `preCheck`, containing execution context or modifications.\n    function postCheck(bytes calldata hookData) external;\n}\n"},"contracts/interfaces/modules/IExecutor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Nexus - IExecutor Interface\n/// @notice Defines the interface for Executor modules within the Nexus Smart Account framework, compliant with the ERC-7579 standard.\n/// @dev Extends IModule to include functionalities specific to execution modules.\n/// This interface is future-proof, allowing for expansion and integration of advanced features in subsequent versions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IExecutor is IModule {\n    // Future methods for execution management will be defined here to accommodate evolving requirements.\n}\n"},"contracts/interfaces/modules/IFallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Nexus - IFallback Interface\n/// @notice Defines the interface for Fallback modules within the Nexus Smart Account framework, compliant with the ERC-7579 standard.\n/// @dev Extends IModule to include functionalities specific to fallback modules.\n/// This interface is future-proof, allowing for expansion and integration of advanced features in subsequent versions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IFallback is IModule {\n    // Future methods for fallback management will be defined here to accommodate evolving blockchain technologies.\n}\n"},"contracts/interfaces/modules/IValidator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IValidator is IModule {\n    /// @notice Validates a user operation as per ERC-4337 standard requirements.\n    /// @dev Should ensure that the signature and nonce are verified correctly before the transaction is allowed to proceed.\n    /// The function returns a status code indicating validation success or failure.\n    /// @param userOp The user operation containing transaction details to be validated.\n    /// @param userOpHash The hash of the user operation data, used for verifying the signature.\n    /// @return status The result of the validation process, typically indicating success or the type of failure.\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external returns (uint256);\n\n    /// @notice Verifies a signature against a hash, using the sender's address as a contextual check.\n    /// @dev Used to confirm the validity of a signature against the specific conditions set by the sender.\n    /// @param sender The address from which the operation was initiated, adding an additional layer of validation against the signature.\n    /// @param hash The hash of the data signed.\n    /// @param data The signature data to validate.\n    /// @return magicValue A bytes4 value that corresponds to the ERC-1271 standard, indicating the validity of the signature.\n    function isValidSignatureWithSender(address sender, bytes32 hash, bytes calldata data) external view returns (bytes4);\n}\n"},"contracts/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/// @title ModeLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n/// encoding is used.\n///    Function Signature of execute function:\n///           function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n/// This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n/// context.\n/// NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n/// implement\n/// more complex execution modes may use the entire bytes32.\n///\n/// |--------------------------------------------------------------------|\n/// | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n/// |--------------------------------------------------------------------|\n/// | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n/// |--------------------------------------------------------------------|\n///\n/// CALLTYPE: 1 byte\n/// CallType is used to determine how the executeCalldata paramter of the execute function has to be\n/// decoded.\n/// It can be either single, batch or delegatecall. In the future different calls could be added.\n/// CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n///\n/// EXECTYPE: 1 byte\n/// ExecType is used to determine how the account should handle the execution.\n/// It can indicate if the execution should revert on failure or continue execution.\n/// In the future more execution modes may be added.\n/// Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n/// a batch fails, the entire batch is reverted\n///\n/// UNUSED: 4 bytes\n/// Unused bytes are reserved for future use.\n///\n/// ModeSelector: bytes4\n/// The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n/// their accounts.\n/// the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n/// this is to prevent collisions between different vendors, while allowing innovation and the\n/// development of new features without coordination between ERC-7579 implementing accounts\n///\n/// ModePayload: 22 bytes\n/// Mode payload is used to pass additional data to the smart account execution, this may be\n/// interpreted depending on the ModeSelector\n///\n/// ExecutionCallData: n bytes\n/// single, delegatecall or batch exec abi.encoded as bytes\n\n// Custom type for improved developer experience\ntype ExecutionMode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/// @dev ModeLib is a helper library to encode/decode ModeCodes\nlibrary ModeLib {\n    function decode(\n        ExecutionMode mode\n    ) internal pure returns (CallType _calltype, ExecType _execType, ModeSelector _modeSelector, ModePayload _modePayload) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function decodeBasic(ExecutionMode mode) internal pure returns (CallType _calltype, ExecType _execType) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n        }\n    }\n\n    function encode(CallType callType, ExecType execType, ModeSelector mode, ModePayload payload) internal pure returns (ExecutionMode) {\n        return ExecutionMode.wrap(bytes32(abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)));\n    }\n\n    function encodeSimpleBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTrySingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTryBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeCustom(CallType callType, ExecType execType) internal pure returns (ExecutionMode mode) {\n        mode = encode(callType, execType, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ExecutionMode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { _eqModeSelector as == } for ModeSelector global;\nusing { _eqCallType as == } for CallType global;\nusing { _uneqCallType as != } for CallType global;\nusing { _eqExecType as == } for ExecType global;\n\nfunction _eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction _uneqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction _eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\n//slither-disable-next-line dead-code\nfunction _eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"contracts/lib/ExecLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Execution } from \"../types/DataTypes.sol\";\n\n/// @title ExecutionLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// Helper Library for decoding Execution calldata\n/// malloc for memory allocation is bad for gas. use this assembly instead\nlibrary ExecLib {\n    error InvalidBatchCallData();\n\n    function get2771CallData(bytes calldata cd) internal view returns (bytes memory callData) {\n        /// @solidity memory-safe-assembly\n        (cd);\n        assembly {\n            // as per solidity docs\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            callData := allocate(add(calldatasize(), 0x20)) //allocate extra 0x20 to store length\n            mstore(callData, add(calldatasize(), 0x14)) //store length, extra 0x14 is for msg.sender address\n            calldatacopy(add(callData, 0x20), 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            let senderPtr := allocate(0x14)\n            mstore(senderPtr, shl(96, caller()))\n        }\n    }\n\n    function decodeBatch(bytes calldata callData) internal view returns (Execution[] calldata executionBatch) {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n         * 0x4                  | -                 | abi.encode(IERC7579Execution.Execution[])\n         */\n        assembly (\"memory-safe\") {\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }   \n\n    function encodeBatch(Execution[] memory executions) internal pure returns (bytes memory callData) {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata) internal pure returns (address target, uint256 value, bytes calldata callData) {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function decodeDelegateCall(bytes calldata executionCalldata) internal pure returns (address delegate, bytes calldata callData) {\n        // destructure executionCallData according to single exec\n        delegate = address(uint160(bytes20(executionCalldata[0:20])));\n        callData = executionCalldata[20:];\n    }\n\n    function encodeSingle(address target, uint256 value, bytes memory callData) internal pure returns (bytes memory userOpCalldata) {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"contracts/lib/local/LocalCallDataParserLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\nlibrary LocalCallDataParserLib {\n    /// @dev Parses the `userOp.signature` to extract the module type, module initialization data,\n    ///      enable mode signature, and user operation signature. The `userOp.signature` must be\n    ///      encoded in a specific way to be parsed correctly.\n    /// @param packedData The packed signature data, typically coming from `userOp.signature`.\n    /// @return module The address of the module.\n    /// @return moduleType The type of module as a `uint256`.\n    /// @return moduleInitData Initialization data specific to the module.\n    /// @return enableModeSignature Signature used to enable the module mode.\n    /// @return userOpSignature The remaining user operation signature data.\n    function parseEnableModeData(\n        bytes calldata packedData\n    )\n        internal\n        pure\n        returns (\n            address module,\n            uint256 moduleType,\n            bytes calldata moduleInitData,\n            bytes calldata enableModeSignature,\n            bytes calldata userOpSignature\n        )\n    {\n        uint256 p;\n        assembly (\"memory-safe\") {\n            p := packedData.offset\n            module := shr(96, calldataload(p))\n\n            p := add(p, 0x14)\n            moduleType := calldataload(p)\n\n            moduleInitData.length := shr(224, calldataload(add(p, 0x20)))\n            moduleInitData.offset := add(p, 0x24)\n            p := add(moduleInitData.offset, moduleInitData.length)\n\n            enableModeSignature.length := shr(224, calldataload(p))\n            enableModeSignature.offset := add(p, 0x04)\n            p := sub(add(enableModeSignature.offset, enableModeSignature.length), packedData.offset)\n        }\n        userOpSignature = packedData[p:];\n    }\n\n    /// @dev Parses the data to obtain types and initdata's for Multi Type module install mode\n    /// @param initData Multi Type module init data, abi.encoded\n    function parseMultiTypeInitData(bytes calldata initData) internal pure returns (uint256[] calldata types, bytes[] calldata initDatas) {\n        // equivalent of:\n        // (types, initDatas) = abi.decode(initData,(uint[],bytes[]))\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            initDatas.offset := add(dataPointer, 32)\n            initDatas.length := calldataload(dataPointer)\n        }\n    }\n}\n"},"contracts/interfaces/base/IModuleManagerEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { CallType } from \"../../lib/ModeLib.sol\";\n\n/// @title ERC-7579 Module Manager Events and Errors Interface\n/// @notice Provides event and error definitions for actions related to module management in smart accounts.\n/// @dev Used by IModuleManager to define the events and errors associated with the installation and management of modules.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManagerEventsAndErrors {\n    /// @notice Emitted when a module is installed onto a smart account.\n    /// @param moduleTypeId The identifier for the type of module installed.\n    /// @param module The address of the installed module.\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Emitted when a module is uninstalled from a smart account.\n    /// @param moduleTypeId The identifier for the type of module uninstalled.\n    /// @param module The address of the uninstalled module.\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Thrown when attempting to remove the last validator.\n    error CanNotRemoveLastValidator();\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error ValidatorNotInstalled(address module);\n\n    /// @dev Thrown when there is no installed validator detected.\n    error NoValidatorInstalled();\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error InvalidModule(address module);\n\n    /// @dev Thrown when an invalid module type identifier is provided.\n    error InvalidModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a module that is already installed.\n    error ModuleAlreadyInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when an operation is performed by an unauthorized operator.\n    error UnauthorizedOperation(address operator);\n\n    /// @dev Thrown when there is an attempt to uninstall a module that is not installed.\n    error ModuleNotInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when a module address is set to zero.\n    error ModuleAddressCanNotBeZero();\n\n    /// @dev Thrown when a post-check fails after hook execution.\n    error HookPostCheckFailed();\n\n    /// @dev Thrown when there is an attempt to install a hook while another is already installed.\n    error HookAlreadyInstalled(address currentHook);\n\n    /// @dev Thrown when there is an attempt to install a fallback handler for a selector already having one.\n    error FallbackAlreadyInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when there is an attempt to uninstall a fallback handler for a selector that does not have one installed.\n    error FallbackNotInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when a fallback handler fails to uninstall properly.\n    error FallbackHandlerUninstallFailed();\n\n    /// @dev Thrown when no fallback handler is available for a given selector.\n    error MissingFallbackHandler(bytes4 selector);\n\n    /// @dev Thrown when Invalid data is provided for MultiType install flow\n    error InvalidInput();\n\n    /// @dev Thrown when unable to validate Module Enable Mode signature\n    error EnableModeSigError();\n\n    /// Error thrown when account installs/uninstalls module with mismatched input `moduleTypeId`\n    error MismatchModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a forbidden selector as a fallback handler.\n    error FallbackSelectorForbidden();\n\n    /// @dev Thrown when there is an attempt to install a fallback handler with an invalid calltype for a given selector.\n    error FallbackCallTypeInvalid();\n\n    /// @notice Error thrown when an execution with an unsupported CallType was made.\n    /// @param callType The unsupported call type.\n    error UnsupportedCallType(CallType callType);\n}\n"},"contracts/types/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n// Magic value for ERC-1271 valid signature\nbytes4 constant ERC1271_MAGICVALUE = 0x1626ba7e;\n\n// Value indicating an invalid ERC-1271 signature\nbytes4 constant ERC1271_INVALID = 0xFFFFFFFF;\n\n// Value indicating successful validation\nuint256 constant VALIDATION_SUCCESS = 0;\n\n// Value indicating failed validation\nuint256 constant VALIDATION_FAILED = 1;\n\n// Module type identifier for Multitype install\nuint256 constant MODULE_TYPE_MULTI = 0;\n\n// Module type identifier for validators\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\n\n// Module type identifier for executors\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\n\n// Module type identifier for fallback handlers\nuint256 constant MODULE_TYPE_FALLBACK = 3;\n\n// Module type identifier for hooks\nuint256 constant MODULE_TYPE_HOOK = 4;\n\nstring constant MODULE_ENABLE_MODE_NOTATION = \"ModuleEnableMode(address module,uint256 moduleType,bytes32 userOpHash,bytes32 initDataHash)\";\nbytes32 constant MODULE_ENABLE_MODE_TYPE_HASH = keccak256(bytes(MODULE_ENABLE_MODE_NOTATION));\n\n// Validation modes\nbytes1 constant MODE_VALIDATION = 0x00;\nbytes1 constant MODE_MODULE_ENABLE = 0x01;\n\nbytes4 constant SUPPORTS_ERC7739 = 0x77390000;\nbytes4 constant SUPPORTS_ERC7739_V1 = 0x77390001;"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\")`.\n    /// This is only used in `_hashTypedDataSansChainId`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID =\n        0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID.\n    /// We expect that most contracts will use `_hashTypedData` as the main hash,\n    /// and `_hashTypedDataSansChainId` only occasionally for cross-chain workflows.\n    /// Thus this is optimized for smaller bytecode size over runtime gas.\n    function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/excessively-safe-call/src/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"},"contracts/base/RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n/// @title RegistryAdapter\n/// @notice This contract provides an interface for interacting with an ERC-7484 compliant registry.\n/// @dev The registry feature is opt-in, allowing the smart account owner to select and trust specific attesters.\nabstract contract RegistryAdapter {\n    IERC7484 public registry;\n\n    /// @notice Emitted when a new ERC-7484 registry is configured for the account.\n    /// @param registry The configured registry contract.\n    event ERC7484RegistryConfigured(IERC7484 indexed registry);\n\n    /// @notice Modifier to check if a module meets the required attestations in the registry.\n    /// @param module The module to check.\n    /// @param moduleType The type of the module to verify in the registry.\n    modifier withRegistry(address module, uint256 moduleType) {\n        _checkRegistry(module, moduleType);\n        _;\n    }\n\n    /// @notice Configures the ERC-7484 registry and sets trusted attesters.\n    /// @param newRegistry The new registry contract to use.\n    /// @param attesters The list of attesters to trust.\n    /// @param threshold The number of attestations required.\n    function _configureRegistry(IERC7484 newRegistry, address[] calldata attesters, uint8 threshold) internal {\n        registry = newRegistry;\n        if (address(newRegistry) != address(0)) {\n            newRegistry.trustAttesters(threshold, attesters);\n        }\n        emit ERC7484RegistryConfigured(newRegistry);\n    }\n\n    /// @notice Checks the registry to ensure sufficient valid attestations for a module.\n    /// @param module The module to check.\n    /// @param moduleType The type of the module to verify in the registry.\n    /// @dev Reverts if the required attestations are not met.\n    function _checkRegistry(address module, uint256 moduleType) internal view {\n        IERC7484 moduleRegistry = registry;\n        if (address(moduleRegistry) != address(0)) {\n            // This will revert if attestations or the threshold are not met.\n            moduleRegistry.check(module, moduleType);\n        }\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"contracts/interfaces/base/IExecutionHelperEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution Manager Events and Errors Interface\n/// @notice Interface for defining events and errors related to transaction execution processes within smart accounts.\n/// @dev This interface defines events and errors used by execution manager to handle and report the operational status of smart account transactions.\n/// It is a part of the Nexus suite of contracts aimed at implementing flexible and secure smart account operations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\n\nimport { ExecType } from \"../../lib/ModeLib.sol\";\n\ninterface IExecutionHelperEventsAndErrors {\n    /// @notice Event emitted when a transaction fails to execute successfully.\n    event TryExecuteUnsuccessful(bytes callData, bytes result);\n\n    /// @notice Event emitted when a transaction fails to execute successfully.\n    event TryDelegateCallUnsuccessful(bytes callData, bytes result);\n\n    /// @notice Error thrown when an execution with an unsupported ExecType was made.\n    /// @param execType The unsupported execution type.\n    error UnsupportedExecType(ExecType execType);\n}\n"},"contracts/interfaces/base/IStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\n\nimport { IHook } from \"../modules/IHook.sol\";\nimport { CallType } from \"../../lib/ModeLib.sol\";\n\n/// @title Nexus - IStorage Interface\n/// @notice Provides structured storage for Modular Smart Account under the Nexus suite, compliant with ERC-7579 and ERC-4337.\n/// @dev Manages structured storage using SentinelListLib for validators and executors, and a mapping for fallback handlers.\n/// This interface utilizes ERC-7201 storage location practices to ensure isolated and collision-resistant storage spaces within smart contracts.\n/// It is designed to support dynamic execution and modular management strategies essential for advanced smart account architectures.\n/// @custom:storage-location erc7201:biconomy.storage.Nexus\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IStorage {\n    /// @notice Struct storing validators and executors using Sentinel lists, and fallback handlers via mapping.\n    struct AccountStorage {\n        SentinelListLib.SentinelList validators; ///< List of validators, initialized upon contract deployment.\n        SentinelListLib.SentinelList executors; ///< List of executors, similarly initialized.\n        mapping(bytes4 => FallbackHandler) fallbacks; ///< Mapping of selectors to their respective fallback handlers.\n        IHook hook; ///< Current hook module associated with this account.\n        mapping(address hook => uint256) emergencyUninstallTimelock; ///< Mapping of hooks to requested timelocks.\n    }\n\n    /// @notice Defines a fallback handler with an associated handler address and a call type.\n    struct FallbackHandler {\n        address handler; ///< The address of the fallback function handler.\n        CallType calltype; ///< The type of call this handler supports (e.g., static or call).\n    }\n}\n"},"contracts/types/DataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution\n/// @notice Struct to encapsulate execution data for a transaction\nstruct Execution {\n    /// @notice The target address for the transaction\n    address target;\n    /// @notice The value in wei to send with the transaction\n    uint256 value;\n    /// @notice The calldata for the transaction\n    bytes callData;\n}\n"}},"settings":{"remappings":["@openzeppelin/=node_modules/@openzeppelin/","forge-std/=node_modules/forge-std/src/","account-abstraction/=node_modules/account-abstraction/contracts/","solady/=node_modules/solady/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","sentinellist/=node_modules/sentinellist/src/","solarray/=node_modules/solarray/src/","erc7739Validator/=node_modules/erc7739-validator-base/src/","@ERC4337/=node_modules/@ERC4337/","@biconomy/=node_modules/@biconomy/","@erc7579/=node_modules/@erc7579/","@gnosis.pm/=node_modules/@gnosis.pm/","@prb/=node_modules/@prb/","@rhinestone/=node_modules/@rhinestone/","@safe-global/=node_modules/@safe-global/","@zerodev/=node_modules/@zerodev/","ExcessivelySafeCall/=node_modules/erc7739-validator-base/node_modules/excessively-safe-call/src/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/","ds-test/=node_modules/ds-test/","enumerableset4337/=node_modules/erc7739-validator-base/node_modules/@erc7579/enumerablemap4337/src/","erc4337-validation/=node_modules/erc7739-validator-base/node_modules/@rhinestone/erc4337-validation/src/","erc7579/=node_modules/erc7579/","erc7739-validator-base/=node_modules/erc7739-validator-base/","eth-gas-reporter/=node_modules/eth-gas-reporter/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","kernel/=node_modules/erc7739-validator-base/node_modules/@zerodev/kernel/src/","module-bases/=node_modules/erc7739-validator-base/node_modules/@rhinestone/module-bases/src/","modulekit/=node_modules/erc7739-validator-base/node_modules/@rhinestone/modulekit/src/","prep/=node_modules/prep/","safe7579/=node_modules/erc7739-validator-base/node_modules/@rhinestone/safe7579/src/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
