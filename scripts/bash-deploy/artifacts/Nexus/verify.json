{"language":"Solidity","sources":{"contracts/Nexus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { UUPSUpgradeable } from \"solady/utils/UUPSUpgradeable.sol\";\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\nimport { ExecLib } from \"./lib/ExecLib.sol\";\nimport { INexus } from \"./interfaces/INexus.sol\";\nimport { BaseAccount } from \"./base/BaseAccount.sol\";\nimport { IERC7484 } from \"./interfaces/IERC7484.sol\";\nimport { ModuleManager } from \"./base/ModuleManager.sol\";\nimport { ExecutionHelper } from \"./base/ExecutionHelper.sol\";\nimport { IValidator } from \"./interfaces/modules/IValidator.sol\";\nimport { MODULE_TYPE_VALIDATOR, MODULE_TYPE_EXECUTOR, MODULE_TYPE_FALLBACK, MODULE_TYPE_HOOK, MODULE_TYPE_MULTI, SUPPORTS_ERC7739 } from \"./types/Constants.sol\";\nimport { ModeLib, ExecutionMode, ExecType, CallType, CALLTYPE_BATCH, CALLTYPE_SINGLE, CALLTYPE_DELEGATECALL, EXECTYPE_DEFAULT, EXECTYPE_TRY } from \"./lib/ModeLib.sol\";\nimport { NonceLib } from \"./lib/NonceLib.sol\";\nimport { SentinelListLib, SENTINEL, ZERO_ADDRESS } from \"sentinellist/SentinelList.sol\";\n\n/// @title Nexus - Smart Account\n/// @notice This contract integrates various functionalities to handle modular smart accounts compliant with ERC-7579 and ERC-4337 standards.\n/// @dev Comprehensive suite of methods for managing smart accounts, integrating module management, execution management, and upgradability via UUPS.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Nexus is INexus, BaseAccount, ExecutionHelper, ModuleManager, UUPSUpgradeable {\n    using ModeLib for ExecutionMode;\n    using ExecLib for bytes;\n    using NonceLib for uint256;\n    using SentinelListLib for SentinelListLib.SentinelList;\n\n    /// @dev The timelock period for emergency hook uninstallation.\n    uint256 internal constant _EMERGENCY_TIMELOCK = 1 days;\n\n    /// @dev The event emitted when an emergency hook uninstallation is initiated.\n    event EmergencyHookUninstallRequest(address hook, uint256 timestamp);\n\n    /// @dev The event emitted when an emergency hook uninstallation request is reset.\n    event EmergencyHookUninstallRequestReset(address hook, uint256 timestamp);\n\n    /// @notice Initializes the smart account with the specified entry point.\n    constructor(address anEntryPoint) {\n        require(address(anEntryPoint) != address(0), EntryPointCanNotBeZero());\n        _ENTRYPOINT = anEntryPoint;\n        _initModuleManager();\n    }\n\n    /// @notice Validates a user operation against a specified validator, extracted from the operation's nonce.\n    /// @param op The user operation to validate, encapsulating all transaction details.\n    /// @param userOpHash Hash of the user operation data, used for signature validation.\n    /// @param missingAccountFunds Funds missing from the account's deposit necessary for transaction execution.\n    /// This can be zero if covered by a paymaster or if sufficient deposit exists.\n    /// @return validationData Encoded validation result or failure, propagated from the validator module.\n    /// - Encoded format in validationData:\n    ///     - First 20 bytes: Address of the Validator module, to which the validation task is forwarded.\n    ///       The validator module returns:\n    ///         - `SIG_VALIDATION_SUCCESS` (0) indicates successful validation.\n    ///         - `SIG_VALIDATION_FAILED` (1) indicates signature validation failure.\n    /// @dev Expects the validator's address to be encoded in the upper 96 bits of the user operation's nonce.\n    /// This method forwards the validation task to the extracted validator module address.\n    /// @dev The entryPoint calls this function. If validation fails, it returns `VALIDATION_FAILED` (1) otherwise `0`.\n    /// @dev Features Module Enable Mode.\n    /// This Module Enable Mode flow is intended for the module acting as the validator\n    /// for the user operation that triggers the Module Enable Flow. Otherwise, a call to\n    /// `Nexus.installModule` should be included in `userOp.callData`.\n    function validateUserOp(\n        PackedUserOperation calldata op,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual payPrefund(missingAccountFunds) onlyEntryPoint returns (uint256 validationData) {\n        address validator = op.nonce.getValidator();\n        if (op.nonce.isModuleEnableMode()) {\n            PackedUserOperation memory userOp = op;\n            userOp.signature = _enableMode(userOpHash, op.signature);\n            require(_isValidatorInstalled(validator), ValidatorNotInstalled(validator));\n            validationData = IValidator(validator).validateUserOp(userOp, userOpHash);\n        } else {\n            require(_isValidatorInstalled(validator), ValidatorNotInstalled(validator));\n            validationData = IValidator(validator).validateUserOp(op, userOpHash);\n        }\n    }\n\n    /// @notice Executes transactions in single or batch modes as specified by the execution mode.\n    /// @param mode The execution mode detailing how transactions should be handled (single, batch, default, try/catch).\n    /// @param executionCalldata The encoded transaction data to execute.\n    /// @dev This function handles transaction execution flexibility and is protected by the `onlyEntryPoint` modifier.\n    /// @dev This function also goes through hook checks via withHook modifier.\n    function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable onlyEntryPoint withHook {\n        (CallType callType, ExecType execType) = mode.decodeBasic();\n        if (callType == CALLTYPE_SINGLE) {\n            _handleSingleExecution(executionCalldata, execType);\n        } else if (callType == CALLTYPE_BATCH) {\n            _handleBatchExecution(executionCalldata, execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            _handleDelegateCallExecution(executionCalldata, execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /// @notice Executes transactions from an executor module, supporting both single and batch transactions.\n    /// @param mode The execution mode (single or batch, default or try).\n    /// @param executionCalldata The transaction data to execute.\n    /// @return returnData The results of the transaction executions, which may include errors in try mode.\n    /// @dev This function is callable only by an executor module and goes through hook checks.\n    function executeFromExecutor(\n        ExecutionMode mode,\n        bytes calldata executionCalldata\n    ) external payable onlyExecutorModule withHook withRegistry(msg.sender, MODULE_TYPE_EXECUTOR) returns (bytes[] memory returnData) {\n        (CallType callType, ExecType execType) = mode.decodeBasic();\n        // check if calltype is batch or single or delegate call\n        if (callType == CALLTYPE_SINGLE) {\n            returnData = _handleSingleExecutionAndReturnData(executionCalldata, execType);\n        } else if (callType == CALLTYPE_BATCH) {\n            returnData = _handleBatchExecutionAndReturnData(executionCalldata, execType);\n        } else if (callType == CALLTYPE_DELEGATECALL) {\n            returnData = _handleDelegateCallExecutionAndReturnData(executionCalldata, execType);\n        } else {\n            revert UnsupportedCallType(callType);\n        }\n    }\n\n    /// @notice Executes a user operation via a call using the contract's context.\n    /// @param userOp The user operation to execute, containing transaction details.\n    /// @param - Hash of the user operation.\n    /// @dev Only callable by the EntryPoint. Decodes the user operation calldata, skipping the first four bytes, and executes the inner call.\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32) external payable virtual onlyEntryPoint withHook {\n        bytes calldata callData = userOp.callData[4:];\n        (bool success, bytes memory innerCallRet) = address(this).delegatecall(callData);\n        if (success) {\n            emit Executed(userOp, innerCallRet);\n        } else revert ExecutionFailed();\n    }\n\n    /// @notice Installs a new module to the smart account.\n    /// @param moduleTypeId The type identifier of the module being installed, which determines its role:\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// @param module The address of the module to install.\n    /// @param initData Initialization data for the module.\n    /// @dev This function can only be called by the EntryPoint or the account itself for security reasons.\n    /// @dev This function goes through hook checks via withHook modifier through internal function _installModule.\n    function installModule(uint256 moduleTypeId, address module, bytes calldata initData) external payable onlyEntryPointOrSelf {\n        _installModule(moduleTypeId, module, initData);\n        emit ModuleInstalled(moduleTypeId, module);\n    }\n\n    /// @notice Uninstalls a module from the smart account.\n    /// @param moduleTypeId The type ID of the module to be uninstalled, matching the installation type:\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// @param module The address of the module to uninstall.\n    /// @param deInitData De-initialization data for the module.\n    /// @dev Ensures that the operation is authorized and valid before proceeding with the uninstallation.\n    function uninstallModule(uint256 moduleTypeId, address module, bytes calldata deInitData) external payable onlyEntryPointOrSelf withHook {\n        require(_isModuleInstalled(moduleTypeId, module, deInitData), ModuleNotInstalled(moduleTypeId, module));\n        emit ModuleUninstalled(moduleTypeId, module);\n\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _uninstallValidator(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _uninstallExecutor(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _uninstallFallbackHandler(module, deInitData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _uninstallHook(module, deInitData);\n        }\n    }\n\n    function emergencyUninstallHook(address hook, bytes calldata deInitData) external payable onlyEntryPoint {\n        require(_isModuleInstalled(MODULE_TYPE_HOOK, hook, deInitData), ModuleNotInstalled(MODULE_TYPE_HOOK, hook));\n        AccountStorage storage accountStorage = _getAccountStorage();\n        uint256 hookTimelock = accountStorage.emergencyUninstallTimelock[hook];\n\n        if (hookTimelock == 0) {\n            // if the timelock hasnt been initiated, initiate it\n            accountStorage.emergencyUninstallTimelock[hook] = block.timestamp;\n            emit EmergencyHookUninstallRequest(hook, block.timestamp);\n        } else if (block.timestamp >= hookTimelock + 3 * _EMERGENCY_TIMELOCK) {\n            // if the timelock has been left for too long, reset it\n            accountStorage.emergencyUninstallTimelock[hook] = block.timestamp;\n            emit EmergencyHookUninstallRequestReset(hook, block.timestamp);\n        } else if (block.timestamp >= hookTimelock + _EMERGENCY_TIMELOCK) {\n            // if the timelock expired, clear it and uninstall the hook\n            accountStorage.emergencyUninstallTimelock[hook] = 0;\n            _uninstallHook(hook, deInitData);\n            emit ModuleUninstalled(MODULE_TYPE_HOOK, hook);\n        } else {\n            // if the timelock is initiated but not expired, revert\n            revert EmergencyTimeLockNotExpired();\n        }\n    }\n\n    function initializeAccount(bytes calldata initData) external payable virtual {\n        _initModuleManager();\n        (address bootstrap, bytes memory bootstrapCall) = abi.decode(initData, (address, bytes));\n        (bool success, ) = bootstrap.delegatecall(bootstrapCall);\n\n        require(success, NexusInitializationFailed());\n        require(_hasValidators(), NoValidatorInstalled());\n    }\n\n    function setRegistry(IERC7484 newRegistry, address[] calldata attesters, uint8 threshold) external payable onlyEntryPointOrSelf {\n        _configureRegistry(newRegistry, attesters, threshold);\n    }\n\n    /// @notice Validates a signature according to ERC-1271 standards.\n    /// @param hash The hash of the data being validated.\n    /// @param signature Signature data that needs to be validated.\n    /// @return The status code of the signature validation (`0x1626ba7e` if valid).\n    /// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\") = 0x1626ba7e\n    /// @dev Delegates the validation to a validator module specified within the signature data.\n    function isValidSignature(bytes32 hash, bytes calldata signature) external view virtual override returns (bytes4) {\n        // Handle potential ERC7739 support detection request\n        if (signature.length == 0) {\n            // Forces the compiler to optimize for smaller bytecode size.\n            if (uint256(hash) == (~signature.length / 0xffff) * 0x7739) {\n                return checkERC7739Support(hash, signature);\n            }\n        }\n        // else proceed with normal signature verification\n\n        // First 20 bytes of data will be validator address and rest of the bytes is complete signature.\n        address validator = address(bytes20(signature[0:20]));\n        require(_isValidatorInstalled(validator), ValidatorNotInstalled(validator));\n        try IValidator(validator).isValidSignatureWithSender(msg.sender, hash, signature[20:]) returns (bytes4 res) {\n            return res;\n        } catch {\n            return bytes4(0xffffffff);\n        }\n    }\n\n    /// @notice Retrieves the address of the current implementation from the EIP-1967 slot.\n    /// @notice Checks the 1967 implementation slot, if not found then checks the slot defined by address (Biconomy V2 smart account)\n    /// @return implementation The address of the current contract implementation.\n    function getImplementation() external view returns (address implementation) {\n        assembly {\n            implementation := sload(_ERC1967_IMPLEMENTATION_SLOT)\n        }\n        if (implementation == address(0)) {\n            assembly {\n                implementation := sload(address())\n            }\n        }\n    }\n\n    /// @notice Checks if a specific module type is supported by this smart account.\n    /// @param moduleTypeId The identifier of the module type to check.\n    /// @return True if the module type is supported, false otherwise.\n    function supportsModule(uint256 moduleTypeId) external view virtual returns (bool) {\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_EXECUTOR) return true;\n        else if (moduleTypeId == MODULE_TYPE_FALLBACK) return true;\n        else if (moduleTypeId == MODULE_TYPE_HOOK) return true;\n        else if (moduleTypeId == MODULE_TYPE_MULTI) return true;\n        else return false;\n    }\n\n    /// @notice Determines if a specific execution mode is supported.\n    /// @param mode The execution mode to evaluate.\n    /// @return isSupported True if the execution mode is supported, false otherwise.\n    function supportsExecutionMode(ExecutionMode mode) external view virtual returns (bool isSupported) {\n        (CallType callType, ExecType execType) = mode.decodeBasic();\n\n        // Return true if both the call type and execution type are supported.\n        return\n            (callType == CALLTYPE_SINGLE || callType == CALLTYPE_BATCH || callType == CALLTYPE_DELEGATECALL) &&\n            (execType == EXECTYPE_DEFAULT || execType == EXECTYPE_TRY);\n    }\n\n    /// @notice Determines whether a module is installed on the smart account.\n    /// @param moduleTypeId The ID corresponding to the type of module (Validator, Executor, Fallback, Hook).\n    /// @param module The address of the module to check.\n    /// @param additionalContext Optional context that may be needed for certain checks.\n    /// @return True if the module is installed, false otherwise.\n    function isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) external view returns (bool) {\n        return _isModuleInstalled(moduleTypeId, module, additionalContext);\n    }\n\n    /// @dev EIP712 hashTypedData method.\n    function hashTypedData(bytes32 structHash) external view returns (bytes32) {\n        return _hashTypedData(structHash);\n    }\n\n    /// @dev EIP712 domain separator.\n    // solhint-disable func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return _domainSeparator();\n    }\n\n    /// Returns the account's implementation ID.\n    /// @return The unique identifier for this account implementation.\n    function accountId() external pure virtual returns (string memory) {\n        return _ACCOUNT_IMPLEMENTATION_ID;\n    }\n\n    /// Upgrades the contract to a new implementation and calls a function on the new contract.\n    /// @notice Updates two slots 1. ERC1967 slot and\n    /// 2. address() slot in case if it's potentially upgraded earlier from Biconomy V2 account,\n    /// as Biconomy v2 Account (proxy) reads implementation from the slot that is defined by its address\n    /// @param newImplementation The address of the new contract implementation.\n    /// @param data The calldata to be sent to the new implementation.\n    function upgradeToAndCall(address newImplementation, bytes calldata data) public payable virtual override withHook {\n        require(newImplementation != address(0), InvalidImplementationAddress());\n        bool res;\n        assembly {\n            res := gt(extcodesize(newImplementation), 0)\n        }\n        require(res, InvalidImplementationAddress());\n        // update the address() storage slot as well.\n        assembly {\n            sstore(address(), newImplementation)\n        }\n        UUPSUpgradeable.upgradeToAndCall(newImplementation, data);\n    }\n\n    /// @dev For automatic detection that the smart account supports the ERC7739 workflow\n    /// Iterates over all the validators but only if this is a detection request\n    /// ERC-7739 spec assumes that if the account doesn't support ERC-7739\n    /// it will try to handle the detection request as it was normal sig verification\n    /// request and will return 0xffffffff since it won't be able to verify the 0x signature\n    /// against 0x7739...7739 hash.\n    /// So this approach is consistent with the ERC-7739 spec.\n    /// If no validator supports ERC-7739, this function returns false\n    /// thus the account will proceed with normal signature verification\n    /// and return 0xffffffff as a result.\n    function checkERC7739Support(bytes32 hash, bytes calldata signature) public view virtual returns (bytes4) {\n        bytes4 result; \n        unchecked {\n            SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n            address next = validators.entries[SENTINEL];\n            while (next != ZERO_ADDRESS && next != SENTINEL) {\n                bytes4 support = IValidator(next).isValidSignatureWithSender(msg.sender, hash, signature);\n                if (bytes2(support) == bytes2(SUPPORTS_ERC7739) && support > result) {\n                    result = support;\n                }\n                next = validators.getNext(next);\n            }\n        }\n        return result == bytes4(0) ? bytes4(0xffffffff) : result;\n    }\n\n    /// @dev Ensures that only authorized callers can upgrade the smart contract implementation.\n    /// This is part of the UUPS (Universal Upgradeable Proxy Standard) pattern.\n    /// @param newImplementation The address of the new implementation to upgrade to.\n    function _authorizeUpgrade(address newImplementation) internal virtual override(UUPSUpgradeable) onlyEntryPointOrSelf {}\n\n    /// @dev EIP712 domain name and version.\n    function _domainNameAndVersion() internal pure override returns (string memory name, string memory version) {\n        name = \"Nexus\";\n        version = \"1.0.2\";\n    }\n}\n"},"node_modules/solady/src/utils/UUPSUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {CallContextChecker} from \"./CallContextChecker.sol\";\n\n/// @notice UUPS proxy mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/UUPSUpgradeable.sol)\n/// @author Modified from OpenZeppelin\n/// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/UUPSUpgradeable.sol)\n///\n/// @dev Note:\n/// - This implementation is intended to be used with ERC1967 proxies.\n/// See: `LibClone.deployERC1967` and related functions.\n/// - This implementation is NOT compatible with legacy OpenZeppelin proxies\n/// which do not store the implementation at `_ERC1967_IMPLEMENTATION_SLOT`.\nabstract contract UUPSUpgradeable is CallContextChecker {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The upgrade failed.\n    error UpgradeFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Emitted when the proxy's implementation is upgraded.\n    event Upgraded(address indexed implementation);\n\n    /// @dev `keccak256(bytes(\"Upgraded(address)\"))`.\n    uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ERC-1967 storage slot for the implementation in the proxy.\n    /// `uint256(keccak256(\"eip1967.proxy.implementation\")) - 1`.\n    bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      UUPS OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to check if `msg.sender` is authorized\n    /// to upgrade the proxy to `newImplementation`, reverting if not.\n    /// ```\n    ///     function _authorizeUpgrade(address) internal override onlyOwner {}\n    /// ```\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /// @dev Returns the storage slot used by the implementation,\n    /// as specified in [ERC1822](https://eips.ethereum.org/EIPS/eip-1822).\n    ///\n    /// Note: The `notDelegated` modifier prevents accidental upgrades to\n    /// an implementation that is a proxy contract.\n    function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }\n\n    /// @dev Upgrades the proxy's implementation to `newImplementation`.\n    /// Emits a {Upgraded} event.\n    ///\n    /// Note: Passing in empty `data` skips the delegatecall to `newImplementation`.\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x00, returndatasize())\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }\n}\n"},"node_modules/account-abstraction/contracts/interfaces/PackedUserOperation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/**\n * User Operation struct\n * @param sender                - The sender account of this request.\n * @param nonce                 - Unique value the sender uses to verify it is not a replay.\n * @param initCode              - If set, the account contract will be created by this constructor/\n * @param callData              - The method call to execute on this account.\n * @param accountGasLimits      - Packed gas limits for validateUserOp and gas limit passed to the callData method call.\n * @param preVerificationGas    - Gas not calculated by the handleOps method, but added to the gas paid.\n *                                Covers batch overhead.\n * @param gasFees               - packed gas fields maxPriorityFeePerGas and maxFeePerGas - Same as EIP-1559 gas parameters.\n * @param paymasterAndData      - If set, this field holds the paymaster address, verification gas limit, postOp gas limit and paymaster-specific extra data\n *                                The paymaster will pay for the transaction instead of the sender.\n * @param signature             - Sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct PackedUserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    bytes32 accountGasLimits;\n    uint256 preVerificationGas;\n    bytes32 gasFees;\n    bytes paymasterAndData;\n    bytes signature;\n}\n"},"contracts/lib/ExecLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { Execution } from \"../types/DataTypes.sol\";\n\n/// @title ExecutionLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// Helper Library for decoding Execution calldata\n/// malloc for memory allocation is bad for gas. use this assembly instead\nlibrary ExecLib {\n    error InvalidBatchCallData();\n\n    function get2771CallData(bytes calldata cd) internal view returns (bytes memory callData) {\n        /// @solidity memory-safe-assembly\n        (cd);\n        assembly {\n            // as per solidity docs\n            function allocate(length) -> pos {\n                pos := mload(0x40)\n                mstore(0x40, add(pos, length))\n            }\n\n            callData := allocate(add(calldatasize(), 0x20)) //allocate extra 0x20 to store length\n            mstore(callData, add(calldatasize(), 0x14)) //store length, extra 0x14 is for msg.sender address\n            calldatacopy(add(callData, 0x20), 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            let senderPtr := allocate(0x14)\n            mstore(senderPtr, shl(96, caller()))\n        }\n    }\n\n    function decodeBatch(bytes calldata callData) internal view returns (Execution[] calldata executionBatch) {\n        /*\n         * Batch Call Calldata Layout\n         * Offset (in bytes)    | Length (in bytes) | Contents\n         * 0x0                  | 0x4               | bytes4 function selector\n         * 0x4                  | -                 | abi.encode(IERC7579Execution.Execution[])\n         */\n        assembly (\"memory-safe\") {\n            let dataPointer := add(callData.offset, calldataload(callData.offset))\n            // Extract the ERC7579 Executions\n            executionBatch.offset := add(dataPointer, 32)\n            executionBatch.length := calldataload(dataPointer)\n        }\n    }   \n\n    function encodeBatch(Execution[] memory executions) internal pure returns (bytes memory callData) {\n        callData = abi.encode(executions);\n    }\n\n    function decodeSingle(bytes calldata executionCalldata) internal pure returns (address target, uint256 value, bytes calldata callData) {\n        target = address(bytes20(executionCalldata[0:20]));\n        value = uint256(bytes32(executionCalldata[20:52]));\n        callData = executionCalldata[52:];\n    }\n\n    function decodeDelegateCall(bytes calldata executionCalldata) internal pure returns (address delegate, bytes calldata callData) {\n        // destructure executionCallData according to single exec\n        delegate = address(uint160(bytes20(executionCalldata[0:20])));\n        callData = executionCalldata[20:];\n    }\n\n    function encodeSingle(address target, uint256 value, bytes memory callData) internal pure returns (bytes memory userOpCalldata) {\n        userOpCalldata = abi.encodePacked(target, value, callData);\n    }\n}\n"},"contracts/interfaces/INexus.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IERC4337Account } from \"./IERC4337Account.sol\";\nimport { IERC7579Account } from \"./IERC7579Account.sol\";\nimport { INexusEventsAndErrors } from \"./INexusEventsAndErrors.sol\";\n\n/// @title Nexus - INexus Interface\n/// @notice Integrates ERC-4337 and ERC-7579 standards to manage smart accounts within the Nexus suite.\n/// @dev Consolidates ERC-4337 user operations and ERC-7579 configurations into a unified interface for smart account management.\n/// It extends both IERC4337Account and IERC7579Account, enhancing modular capabilities and supporting advanced contract architectures.\n/// Includes error definitions for robust handling of common issues such as unsupported module types and execution failures.\n/// The initialize function sets up the account with validators and configurations, ensuring readiness for use.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface INexus is IERC4337Account, IERC7579Account, INexusEventsAndErrors {\n    /// @notice Initializes the smart account with a validator and custom data.\n    /// @dev This method sets up the account for operation, linking it with a validator and initializing it with specific data.\n    /// Can be called directly or via a factory.\n    /// @param initData Encoded data used for the account's configuration during initialization.\n    function initializeAccount(bytes calldata initData) external payable;\n}\n"},"contracts/base/BaseAccount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IEntryPoint } from \"account-abstraction/interfaces/IEntryPoint.sol\";\nimport { IBaseAccount } from \"../interfaces/base/IBaseAccount.sol\";\n\n/// @title Nexus - BaseAccount\n/// @notice Implements ERC-4337 and ERC-7579 standards for account management and access control within the Nexus suite.\n/// @dev Manages entry points and configurations as specified in the ERC-4337 and ERC-7579 documentation.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract BaseAccount is IBaseAccount {\n    /// @notice Identifier for this implementation on the network\n    string internal constant _ACCOUNT_IMPLEMENTATION_ID = \"biconomy.nexus.1.0.2\";\n\n    /// @notice The canonical address for the ERC4337 EntryPoint contract, version 0.7.\n    /// This address is consistent across all supported networks.\n    address internal immutable _ENTRYPOINT;\n\n    /// @dev Ensures the caller is either the EntryPoint or this account itself.\n    /// Reverts with AccountAccessUnauthorized if the check fails.\n    modifier onlyEntryPointOrSelf() {\n        require(msg.sender == _ENTRYPOINT || msg.sender == address(this), AccountAccessUnauthorized());\n        _;\n    }\n\n    /// @dev Ensures the caller is the EntryPoint.\n    /// Reverts with AccountAccessUnauthorized if the check fails.\n    modifier onlyEntryPoint() {\n        require(msg.sender == _ENTRYPOINT, AccountAccessUnauthorized());\n        _;\n    }\n\n    /// @dev Sends to the EntryPoint (i.e. `msg.sender`) the missing funds for this transaction.\n    /// Subclass MAY override this modifier for better funds management.\n    /// (e.g. send to the EntryPoint more than the minimum required, so that in future transactions\n    /// it will not be required to send again)\n    ///\n    /// `missingAccountFunds` is the minimum value this modifier should send the EntryPoint,\n    /// which MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n    modifier payPrefund(uint256 missingAccountFunds) virtual {\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if missingAccountFunds {\n                // Ignore failure (it's EntryPoint's job to verify, not the account's).\n                pop(call(gas(), caller(), missingAccountFunds, codesize(), 0x00, codesize(), 0x00))\n            }\n        }\n    }\n\n    /// @notice Adds deposit to the EntryPoint to fund transactions.\n    function addDeposit() external payable virtual {\n        address entryPointAddress = _ENTRYPOINT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The EntryPoint has balance accounting logic in the `receive()` function.\n            if iszero(call(gas(), entryPointAddress, callvalue(), codesize(), 0x00, codesize(), 0x00)) {\n                revert(codesize(), 0x00)\n            } // For gas estimation.\n        }\n    }\n\n    /// @notice Withdraws ETH from the EntryPoint to a specified address.\n    /// @param to The address to receive the withdrawn funds.\n    /// @param amount The amount to withdraw.\n    function withdrawDepositTo(address to, uint256 amount) external payable virtual onlyEntryPointOrSelf {\n        address entryPointAddress = _ENTRYPOINT;\n        assembly {\n            let freeMemPtr := mload(0x40) // Store the free memory pointer.\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x205c2878000000000000000000000000) // `withdrawTo(address,uint256)`.\n            if iszero(call(gas(), entryPointAddress, 0, 0x10, 0x44, codesize(), 0x00)) {\n                returndatacopy(freeMemPtr, 0x00, returndatasize())\n                revert(freeMemPtr, returndatasize())\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @notice Gets the nonce for a particular key.\n    /// @param key The nonce key.\n    /// @return The nonce associated with the key.\n    function nonce(uint192 key) external view virtual returns (uint256) {\n        return IEntryPoint(_ENTRYPOINT).getNonce(address(this), key);\n    }\n\n    /// @notice Returns the current deposit balance of this account on the EntryPoint.\n    /// @return result The current balance held at the EntryPoint.\n    function getDeposit() external view virtual returns (uint256 result) {\n        address entryPointAddress = _ENTRYPOINT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, address()) // Store the `account` argument.\n            mstore(0x00, 0x70a08231) // `balanceOf(address)`.\n            result := mul(\n                // Returns 0 if the EntryPoint does not exist.\n                mload(0x20),\n                and(\n                    // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), entryPointAddress, 0x1c, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }\n\n    /// @notice Retrieves the address of the EntryPoint contract, currently using version 0.7.\n    /// @dev This function returns the address of the canonical ERC4337 EntryPoint contract.\n    /// It can be overridden to return a different EntryPoint address if needed.\n    /// @return The address of the EntryPoint contract.\n    function entryPoint() external view returns (address) {\n        return _ENTRYPOINT;\n    }\n}\n"},"contracts/interfaces/IERC7484.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\ninterface IERC7484 {\n    event NewTrustedAttesters();\n\n    /**\n     * Allows Smart Accounts - the end users of the registry - to appoint\n     * one or many attesters as trusted.\n     * @dev this function reverts, if address(0), or duplicates are provided in attesters[]\n     *\n     * @param threshold The minimum number of attestations required for a module\n     *                  to be considered secure.\n     * @param attesters The addresses of the attesters to be trusted.\n     */\n    function trustAttesters(uint8 threshold, address[] calldata attesters) external;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          Check with Registry internal attesters            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n    function check(address module) external view;\n\n    function checkForAccount(address smartAccount, address module) external view;\n\n    function check(address module, uint256 moduleType) external view;\n\n    function checkForAccount(address smartAccount, address module, uint256 moduleType) external view;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              Check with external attester(s)               */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function check(address module, address[] calldata attesters, uint256 threshold) external view;\n\n    function check(address module, uint256 moduleType, address[] calldata attesters, uint256 threshold) external view;\n}\n"},"contracts/base/ModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\nimport { Storage } from \"./Storage.sol\";\nimport { IHook } from \"../interfaces/modules/IHook.sol\";\nimport { IModule } from \"../interfaces/modules/IModule.sol\";\nimport { IExecutor } from \"../interfaces/modules/IExecutor.sol\";\nimport { IFallback } from \"../interfaces/modules/IFallback.sol\";\nimport { IValidator } from \"../interfaces/modules/IValidator.sol\";\nimport { CallType, CALLTYPE_SINGLE, CALLTYPE_STATIC } from \"../lib/ModeLib.sol\";\nimport { ExecLib } from \"../lib/ExecLib.sol\";\nimport { LocalCallDataParserLib } from \"../lib/local/LocalCallDataParserLib.sol\";\nimport { IModuleManagerEventsAndErrors } from \"../interfaces/base/IModuleManagerEventsAndErrors.sol\";\nimport { MODULE_TYPE_VALIDATOR, MODULE_TYPE_EXECUTOR, MODULE_TYPE_FALLBACK, MODULE_TYPE_HOOK, MODULE_TYPE_MULTI, MODULE_ENABLE_MODE_TYPE_HASH, ERC1271_MAGICVALUE } from \"../types/Constants.sol\";\nimport { EIP712 } from \"solady/utils/EIP712.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/ExcessivelySafeCall.sol\";\nimport { RegistryAdapter } from \"./RegistryAdapter.sol\";\n\n/// @title Nexus - ModuleManager\n/// @notice Manages Validator, Executor, Hook, and Fallback modules within the Nexus suite, supporting\n/// @dev Implements SentinelList for managing modules via a linked list structure, adhering to ERC-7579.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\nabstract contract ModuleManager is Storage, EIP712, IModuleManagerEventsAndErrors, RegistryAdapter {\n    using SentinelListLib for SentinelListLib.SentinelList;\n    using LocalCallDataParserLib for bytes;\n    using ExecLib for address;\n    using ExcessivelySafeCall for address;\n\n    /// @notice Ensures the message sender is a registered executor module.\n    modifier onlyExecutorModule() virtual {\n        require(_getAccountStorage().executors.contains(msg.sender), InvalidModule(msg.sender));\n        _;\n    }\n\n    /// @notice Does pre-checks and post-checks using an installed hook on the account.\n    /// @dev sender, msg.data and msg.value is passed to the hook to implement custom flows.\n    modifier withHook() {\n        address hook = _getHook();\n        if (hook == address(0)) {\n            _;\n        } else {\n            bytes memory hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            _;\n            IHook(hook).postCheck(hookData);\n        }\n    }\n\n    receive() external payable {}\n\n    /// @dev Fallback function to manage incoming calls using designated handlers based on the call type.\n    /// Hooked manually in the _fallback function\n    fallback() external payable {\n        _fallback(msg.data);\n    }\n\n    /// @dev Retrieves a paginated list of validator addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of validator modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of validator addresses to return.\n    /// @return array An array of validator addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getValidatorsPaginated(address cursor, uint256 size) external view returns (address[] memory array, address next) {\n        (array, next) = _paginate(_getAccountStorage().validators, cursor, size);\n    }\n\n    /// @dev Retrieves a paginated list of executor addresses from the linked list.\n    /// This utility function is not defined by the ERC-7579 standard and is implemented to facilitate\n    /// easier management and retrieval of large sets of executor modules.\n    /// @param cursor The address to start pagination from, or zero to start from the first entry.\n    /// @param size The number of executor addresses to return.\n    /// @return array An array of executor addresses.\n    /// @return next The address to use as a cursor for the next page of results.\n    function getExecutorsPaginated(address cursor, uint256 size) external view returns (address[] memory array, address next) {\n        (array, next) = _paginate(_getAccountStorage().executors, cursor, size);\n    }\n\n    /// @notice Retrieves the currently active hook address.\n    /// @return hook The address of the active hook module.\n    function getActiveHook() external view returns (address hook) {\n        return _getHook();\n    }\n\n    /// @notice Fetches the fallback handler for a specific selector.\n    /// @param selector The function selector to query.\n    /// @return calltype The type of call that the handler manages.\n    /// @return handler The address of the fallback handler.\n    function getFallbackHandlerBySelector(bytes4 selector) external view returns (CallType, address) {\n        FallbackHandler memory handler = _getAccountStorage().fallbacks[selector];\n        return (handler.calltype, handler.handler);\n    }\n\n    /// @dev Initializes the module manager by setting up default states for validators and executors.\n    function _initModuleManager() internal virtual {\n        // account module storage\n        AccountStorage storage ams = _getAccountStorage();\n        ams.executors.init();\n        ams.validators.init();\n    }\n\n    /// @dev Implements Module Enable Mode flow.\n    /// @param packedData Data source to parse data required to perform Module Enable mode from.\n    /// @return userOpSignature the clean signature which can be further used for userOp validation\n    function _enableMode(bytes32 userOpHash, bytes calldata packedData) internal returns (bytes calldata userOpSignature) {\n        address module;\n        uint256 moduleType;\n        bytes calldata moduleInitData;\n        bytes calldata enableModeSignature;\n\n        (module, moduleType, moduleInitData, enableModeSignature, userOpSignature) = packedData.parseEnableModeData();\n\n        if (!_checkEnableModeSignature(_getEnableModeDataHash(module, moduleType, userOpHash, moduleInitData), enableModeSignature))\n            revert EnableModeSigError();\n\n        _installModule(moduleType, module, moduleInitData);\n    }\n\n    /// @notice Installs a new module to the smart account.\n    /// @param moduleTypeId The type identifier of the module being installed, which determines its role:\n    /// - 0 for MultiType\n    /// - 1 for Validator\n    /// - 2 for Executor\n    /// - 3 for Fallback\n    /// - 4 for Hook\n    /// @param module The address of the module to install.\n    /// @param initData Initialization data for the module.\n    /// @dev This function goes through hook checks via withHook modifier.\n    /// @dev No need to check that the module is already installed, as this check is done\n    /// when trying to sstore the module in an appropriate SentinelList\n    function _installModule(uint256 moduleTypeId, address module, bytes calldata initData) internal withHook {\n        if (module == address(0)) revert ModuleAddressCanNotBeZero();\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            _installValidator(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            _installExecutor(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            _installFallbackHandler(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            _installHook(module, initData);\n        } else if (moduleTypeId == MODULE_TYPE_MULTI) {\n            _multiTypeInstall(module, initData);\n        } else {\n            revert InvalidModuleTypeId(moduleTypeId);\n        }\n    }\n\n    /// @dev Installs a new validator module after checking if it matches the required module type.\n    /// @param validator The address of the validator module to be installed.\n    /// @param data Initialization data to configure the validator upon installation.\n    function _installValidator(address validator, bytes calldata data) internal virtual withRegistry(validator, MODULE_TYPE_VALIDATOR) {\n        if (!IValidator(validator).isModuleType(MODULE_TYPE_VALIDATOR)) revert MismatchModuleTypeId(MODULE_TYPE_VALIDATOR);\n        _getAccountStorage().validators.push(validator);\n        IValidator(validator).onInstall(data);\n    }\n\n    /// @dev Uninstalls a validator module /!\\ ensuring the account retains at least one validator.\n    /// @param validator The address of the validator to be uninstalled.\n    /// @param data De-initialization data to configure the validator upon uninstallation.\n    function _uninstallValidator(address validator, bytes calldata data) internal virtual {\n        SentinelListLib.SentinelList storage validators = _getAccountStorage().validators;\n\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n\n        // Perform the removal first\n        validators.pop(prev, validator);\n\n        // Sentinel pointing to itself / zero means the list is empty / uninitialized, so check this after removal\n        // Below error is very specific to uninstalling validators.\n        require(_hasValidators(), CanNotRemoveLastValidator());\n        validator.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData));\n    }\n\n    /// @dev Installs a new executor module after checking if it matches the required module type.\n    /// @param executor The address of the executor module to be installed.\n    /// @param data Initialization data to configure the executor upon installation.\n    function _installExecutor(address executor, bytes calldata data) internal virtual withRegistry(executor, MODULE_TYPE_EXECUTOR) {\n        if (!IExecutor(executor).isModuleType(MODULE_TYPE_EXECUTOR)) revert MismatchModuleTypeId(MODULE_TYPE_EXECUTOR);\n        _getAccountStorage().executors.push(executor);\n        IExecutor(executor).onInstall(data);\n    }\n\n    /// @dev Uninstalls an executor module by removing it from the executors list.\n    /// @param executor The address of the executor to be uninstalled.\n    /// @param data De-initialization data to configure the executor upon uninstallation.\n    function _uninstallExecutor(address executor, bytes calldata data) internal virtual {\n        (address prev, bytes memory disableModuleData) = abi.decode(data, (address, bytes));\n        _getAccountStorage().executors.pop(prev, executor);\n        executor.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, disableModuleData));\n    }\n\n    /// @dev Installs a hook module, ensuring no other hooks are installed before proceeding.\n    /// @param hook The address of the hook to be installed.\n    /// @param data Initialization data to configure the hook upon installation.\n    function _installHook(address hook, bytes calldata data) internal virtual withRegistry(hook, MODULE_TYPE_HOOK) {\n        if (!IHook(hook).isModuleType(MODULE_TYPE_HOOK)) revert MismatchModuleTypeId(MODULE_TYPE_HOOK);\n        address currentHook = _getHook();\n        require(currentHook == address(0), HookAlreadyInstalled(currentHook));\n        _setHook(hook);\n        IHook(hook).onInstall(data);\n    }\n\n    /// @dev Uninstalls a hook module, ensuring the current hook matches the one intended for uninstallation.\n    /// @param hook The address of the hook to be uninstalled.\n    /// @param data De-initialization data to configure the hook upon uninstallation.\n    function _uninstallHook(address hook, bytes calldata data) internal virtual {\n        _setHook(address(0));\n        hook.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data));\n    }\n\n    /// @dev Sets the current hook in the storage to the specified address.\n    /// @param hook The new hook address.\n    function _setHook(address hook) internal virtual {\n        _getAccountStorage().hook = IHook(hook);\n    }\n\n    /// @dev Installs a fallback handler for a given selector with initialization data.\n    /// @param handler The address of the fallback handler to install.\n    /// @param params The initialization parameters including the selector and call type.\n    function _installFallbackHandler(address handler, bytes calldata params) internal virtual withRegistry(handler, MODULE_TYPE_FALLBACK) {\n        if (!IFallback(handler).isModuleType(MODULE_TYPE_FALLBACK)) revert MismatchModuleTypeId(MODULE_TYPE_FALLBACK);\n        // Extract the function selector from the provided parameters.\n        bytes4 selector = bytes4(params[0:4]);\n\n        // Extract the call type from the provided parameters.\n        CallType calltype = CallType.wrap(bytes1(params[4]));\n\n        require(calltype == CALLTYPE_SINGLE || calltype == CALLTYPE_STATIC, FallbackCallTypeInvalid());\n\n        // Extract the initialization data from the provided parameters.\n        bytes memory initData = params[5:];\n\n        // Revert if the selector is either `onInstall(bytes)` (0x6d61fe70) or `onUninstall(bytes)` (0x8a91b0e3) or explicit bytes(0).\n        // These selectors are explicitly forbidden to prevent security vulnerabilities.\n        // Allowing these selectors would enable unauthorized users to uninstall and reinstall critical modules.\n        // If a validator module is uninstalled and reinstalled without proper authorization, it can compromise\n        // the account's security and integrity. By restricting these selectors, we ensure that the fallback handler\n        // cannot be manipulated to disrupt the expected behavior and security of the account.\n        require(!(selector == bytes4(0x6d61fe70) || selector == bytes4(0x8a91b0e3) || selector == bytes4(0)), FallbackSelectorForbidden());\n\n        // Revert if a fallback handler is already installed for the given selector.\n        // This check ensures that we do not overwrite an existing fallback handler, which could lead to unexpected behavior.\n        require(!_isFallbackHandlerInstalled(selector), FallbackAlreadyInstalledForSelector(selector));\n\n        // Store the fallback handler and its call type in the account storage.\n        // This maps the function selector to the specified fallback handler and call type.\n        _getAccountStorage().fallbacks[selector] = FallbackHandler(handler, calltype);\n\n        // Invoke the `onInstall` function of the fallback handler with the provided initialization data.\n        // This step allows the fallback handler to perform any necessary setup or initialization.\n        IFallback(handler).onInstall(initData);\n    }\n\n    /// @dev Uninstalls a fallback handler for a given selector.\n    /// @param fallbackHandler The address of the fallback handler to uninstall.\n    /// @param data The de-initialization data containing the selector.\n    function _uninstallFallbackHandler(address fallbackHandler, bytes calldata data) internal virtual {\n        _getAccountStorage().fallbacks[bytes4(data[0:4])] = FallbackHandler(address(0), CallType.wrap(0x00));\n        fallbackHandler.excessivelySafeCall(gasleft(), 0, 0, abi.encodeWithSelector(IModule.onUninstall.selector, data[4:]));\n    }\n\n    /// @notice Installs a module with multiple types in a single operation.\n    /// @dev This function handles installing a multi-type module by iterating through each type and initializing it.\n    /// The initData should include an ABI-encoded tuple of (uint[] types, bytes[] initDatas).\n    /// @param module The address of the multi-type module.\n    /// @param initData Initialization data for each type within the module.\n    function _multiTypeInstall(address module, bytes calldata initData) internal virtual {\n        (uint256[] calldata types, bytes[] calldata initDatas) = initData.parseMultiTypeInitData();\n\n        uint256 length = types.length;\n        if (initDatas.length != length) revert InvalidInput();\n\n        // iterate over all module types and install the module as a type accordingly\n        for (uint256 i; i < length; i++) {\n            uint256 theType = types[i];\n\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                      INSTALL VALIDATORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            if (theType == MODULE_TYPE_VALIDATOR) {\n                _installValidator(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL EXECUTORS                    */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_EXECUTOR) {\n                _installExecutor(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*                       INSTALL FALLBACK                     */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_FALLBACK) {\n                _installFallbackHandler(module, initDatas[i]);\n            }\n            /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n            /*          INSTALL HOOK (global only, not sig-specific)      */\n            /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n            else if (theType == MODULE_TYPE_HOOK) {\n                _installHook(module, initDatas[i]);\n            }\n        }\n    }\n\n    /// @notice Checks if an enable mode signature is valid.\n    /// @param structHash data hash.\n    /// @param sig Signature.\n    function _checkEnableModeSignature(bytes32 structHash, bytes calldata sig) internal view returns (bool) {\n        address enableModeSigValidator = address(bytes20(sig[0:20]));\n        if (!_isValidatorInstalled(enableModeSigValidator)) {\n            revert ValidatorNotInstalled(enableModeSigValidator);\n        }\n        bytes32 eip712Digest = _hashTypedData(structHash);\n\n        // Use standard IERC-1271/ERC-7739 interface.\n        // Even if the validator doesn't support 7739 under the hood, it is still secure,\n        // as eip712digest is already built based on 712Domain of this Smart Account\n        // This interface should always be exposed by validators as per ERC-7579\n        try IValidator(enableModeSigValidator).isValidSignatureWithSender(address(this), eip712Digest, sig[20:]) returns (bytes4 res) {\n            return res == ERC1271_MAGICVALUE;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Builds the enable mode data hash as per eip712\n    /// @param module Module being enabled\n    /// @param moduleType Type of the module as per EIP-7579\n    /// @param userOpHash Hash of the User Operation\n    /// @param initData Module init data.\n    /// @return structHash data hash\n    function _getEnableModeDataHash(address module, uint256 moduleType, bytes32 userOpHash, bytes calldata initData) internal view returns (bytes32) {\n        return keccak256(abi.encode(MODULE_ENABLE_MODE_TYPE_HASH, module, moduleType, userOpHash, keccak256(initData)));\n    }\n\n    /// @notice Checks if a module is installed on the smart account.\n    /// @param moduleTypeId The module type ID.\n    /// @param module The module address.\n    /// @param additionalContext Additional context for checking installation.\n    /// @return True if the module is installed, false otherwise.\n    function _isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) internal view returns (bool) {\n        additionalContext;\n        if (moduleTypeId == MODULE_TYPE_VALIDATOR) {\n            return _isValidatorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_EXECUTOR) {\n            return _isExecutorInstalled(module);\n        } else if (moduleTypeId == MODULE_TYPE_FALLBACK) {\n            bytes4 selector;\n            if (additionalContext.length >= 4) {\n                selector = bytes4(additionalContext[0:4]);\n            } else {\n                selector = bytes4(0x00000000);\n            }\n            return _isFallbackHandlerInstalled(selector, module);\n        } else if (moduleTypeId == MODULE_TYPE_HOOK) {\n            return _isHookInstalled(module);\n        } else {\n            return false;\n        }\n    }\n\n    /// @dev Checks if a fallback handler is set for a given selector.\n    /// @param selector The function selector to check.\n    /// @return True if a fallback handler is set, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector) internal view virtual returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler != address(0);\n    }\n\n    /// @dev Checks if the expected fallback handler is installed for a given selector.\n    /// @param selector The function selector to check.\n    /// @param expectedHandler The address of the handler expected to be installed.\n    /// @return True if the installed handler matches the expected handler, otherwise false.\n    function _isFallbackHandlerInstalled(bytes4 selector, address expectedHandler) internal view returns (bool) {\n        FallbackHandler storage handler = _getAccountStorage().fallbacks[selector];\n        return handler.handler == expectedHandler;\n    }\n\n    /// @dev Checks if a validator is currently installed.\n    /// @param validator The address of the validator to check.\n    /// @return True if the validator is installed, otherwise false.\n    function _isValidatorInstalled(address validator) internal view virtual returns (bool) {\n        return _getAccountStorage().validators.contains(validator);\n    }\n\n    /// @dev Checks if there is at least one validator installed.\n    /// @return True if there is at least one validator, otherwise false.\n    function _hasValidators() internal view returns (bool) {\n        return\n            _getAccountStorage().validators.getNext(address(0x01)) != address(0x01) &&\n            _getAccountStorage().validators.getNext(address(0x01)) != address(0x00);\n    }\n\n    /// @dev Checks if an executor is currently installed.\n    /// @param executor The address of the executor to check.\n    /// @return True if the executor is installed, otherwise false.\n    function _isExecutorInstalled(address executor) internal view virtual returns (bool) {\n        return _getAccountStorage().executors.contains(executor);\n    }\n\n    /// @dev Checks if a hook is currently installed.\n    /// @param hook The address of the hook to check.\n    /// @return True if the hook is installed, otherwise false.\n    function _isHookInstalled(address hook) internal view returns (bool) {\n        return _getHook() == hook;\n    }\n\n    /// @dev Retrieves the current hook from the storage.\n    /// @return hook The address of the current hook.\n    function _getHook() internal view returns (address hook) {\n        hook = address(_getAccountStorage().hook);\n    }\n\n    function _fallback(bytes calldata callData) private {\n        bool success;\n        bytes memory result;\n        FallbackHandler storage $fallbackHandler = _getAccountStorage().fallbacks[msg.sig];\n        address handler = $fallbackHandler.handler;\n        CallType calltype = $fallbackHandler.calltype;\n\n        if (handler != address(0)) {\n            // hook manually\n            address hook = _getHook();\n            bytes memory hookData;\n            if (hook != address(0)) {\n                hookData = IHook(hook).preCheck(msg.sender, msg.value, msg.data);\n            }\n            //if there's a fallback handler, call it\n            if (calltype == CALLTYPE_STATIC) {\n                (success, result) = handler.staticcall(ExecLib.get2771CallData(callData));\n            } else if (calltype == CALLTYPE_SINGLE) {\n                (success, result) = handler.call{ value: msg.value }(ExecLib.get2771CallData(callData));\n            } else {\n                revert UnsupportedCallType(calltype);\n            }\n\n            // Use revert message from fallback handler if the call was not successful\n            assembly {\n                if iszero(success) {\n                    revert(add(result, 0x20), mload(result))\n                }\n            }\n\n            // hook post check\n            if (hook != address(0)) {\n                IHook(hook).postCheck(hookData);\n            }\n\n            // return the result\n            assembly {\n                return(add(result, 0x20), mload(result))\n            }\n        }\n        \n        // If there's no handler, the call can be one of onERCXXXReceived()\n        // No need to hook this as no execution is done here\n        bytes32 s;\n        /// @solidity memory-safe-assembly\n        assembly {\n            s := shr(224, calldataload(0))\n            // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`.\n            // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`.\n            // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`.\n            if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) {\n                mstore(0x20, s) // Store `msg.sig`.\n                return(0x3c, 0x20) // Return `msg.sig`.\n            }\n        }\n        // if there was no handler and it is not the onERCXXXReceived call, revert\n        revert MissingFallbackHandler(msg.sig);\n    }\n\n    /// @dev Helper function to paginate entries in a SentinelList.\n    /// @param list The SentinelList to paginate.\n    /// @param cursor The cursor to start paginating from.\n    /// @param size The number of entries to return.\n    /// @return array The array of addresses in the list.\n    /// @return nextCursor The cursor for the next page of entries.\n    function _paginate(\n        SentinelListLib.SentinelList storage list,\n        address cursor,\n        uint256 size\n    ) private view returns (address[] memory array, address nextCursor) {\n        (array, nextCursor) = list.getEntriesPaginated(cursor, size);\n    }\n}\n"},"contracts/base/ExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { Execution } from \"../types/DataTypes.sol\";\nimport { IExecutionHelperEventsAndErrors } from \"../interfaces/base/IExecutionHelper.sol\";\nimport { ExecType, EXECTYPE_DEFAULT, EXECTYPE_TRY } from \"../lib/ModeLib.sol\";\nimport { ExecLib } from \"../lib/ExecLib.sol\";\n\n/// @title Nexus - ExecutionHelper\n/// @notice Implements execution management within the Nexus suite, facilitating transaction execution strategies and\n/// error handling.\n/// @dev Provides mechanisms for direct and batched transactions with both committed and tentative execution strategies\n/// as per ERC-4337 and ERC-7579 standards.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract ExecutionHelper is IExecutionHelperEventsAndErrors {\n    using ExecLib for bytes;\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// @notice calls to an EOA should be counted as successful.\n    /// @param target The address to execute the call on.\n    /// @param value The amount of wei to send with the call.\n    /// @param callData The calldata to send.\n    /// @return result The bytes returned from the execution, which contains the returned data from the target address.\n    function _execute(address target, uint256 value, bytes calldata callData) internal virtual returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @notice Executes a call to a target address with specified value and data.\n    /// Same as _execute but without return data for gas optimization.\n    function _executeNoReturndata(address target, uint256 value, bytes calldata callData) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(call(gas(), target, value, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(0x40, add(result, callData.length)) //allocate memory\n        }\n    }\n\n    /// @notice Tries to execute a call and captures if it was successful or not.\n    /// @dev Similar to _execute but returns a success boolean and catches reverts instead of propagating them.\n    /// @notice calls to an EOA should be counted as successful.\n    /// @param target The address to execute the call on.\n    /// @param value The amount of wei to send with the call.\n    /// @param callData The calldata to send.\n    /// @return success True if the execution was successful, false otherwise.\n    /// @return result The bytes returned from the execution, which contains the returned data from the target address.\n    function _tryExecute(address target, uint256 value, bytes calldata callData) internal virtual returns (bool success, bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            success := call(gas(), target, value, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @notice Executes a batch of calls.\n    /// @param executions An array of Execution structs each containing target, value, and calldata.\n    /// @return result An array of bytes returned from each executed call, corresponding to the returndata from each target address.\n    function _executeBatch(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        result = new bytes[](executions.length);\n\n        Execution calldata exec;\n        for (uint256 i; i < executions.length; i++) {\n            exec = executions[i];\n            result[i] = _execute(exec.target, exec.value, exec.callData);\n        }\n    }\n\n    /// @notice Executes a batch of calls without returning the result.\n    /// @param executions An array of Execution structs each containing target, value, and calldata.\n    function _executeBatchNoReturndata(Execution[] calldata executions) internal {\n        Execution calldata exec;\n        for (uint256 i; i < executions.length; i++) {\n            exec = executions[i];\n            _executeNoReturndata(exec.target, exec.value, exec.callData);\n        }\n    }\n\n    /// @notice Tries to execute a batch of calls and emits an event for each unsuccessful call.\n    /// @param executions An array of Execution structs.\n    /// @return result An array of bytes returned from each executed call, with unsuccessful calls marked by events.\n    function _tryExecuteBatch(Execution[] calldata executions) internal returns (bytes[] memory result) {\n        result = new bytes[](executions.length);\n\n        Execution calldata exec;\n        for (uint256 i; i < executions.length; i++) {\n            exec = executions[i];\n            bool success;\n            (success, result[i]) = _tryExecute(exec.target, exec.value, exec.callData);\n            if (!success) emit TryExecuteUnsuccessful(exec.callData, result[i]);\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    /// @return result The bytes returned from the delegatecall, which contains the returned data from the delegate contract.\n    function _executeDelegatecall(address delegate, bytes calldata callData) internal returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account.\n    /// Same as _executeDelegatecall but without return data for gas optimization.\n    function _executeDelegatecallNoReturndata(address delegate, bytes calldata callData) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            if iszero(delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            mstore(0x40, add(result, callData.length)) //allocate memory\n        }\n    }\n\n    /// @dev Execute a delegatecall with `delegate` on this account and catch reverts.\n    /// @return success True if the delegatecall was successful, false otherwise.\n    /// @return result The bytes returned from the delegatecall, which contains the returned data from the delegate contract.\n    function _tryExecuteDelegatecall(address delegate, bytes calldata callData) internal returns (bool success, bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            calldatacopy(result, callData.offset, callData.length)\n            // Forwards the `data` to `delegate` via delegatecall.\n            success := delegatecall(gas(), delegate, result, callData.length, codesize(), 0x00)\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    function _handleSingleExecution(bytes calldata executionCalldata, ExecType execType) internal {\n        (address target, uint256 value, bytes calldata callData) = executionCalldata.decodeSingle();\n        if (execType == EXECTYPE_DEFAULT) _executeNoReturndata(target, value, callData);\n        else if (execType == EXECTYPE_TRY) {\n            (bool success, bytes memory result) = _tryExecute(target, value, callData);\n            if (!success) emit TryExecuteUnsuccessful(callData, result);\n        } else revert UnsupportedExecType(execType);\n    }\n\n    /// @dev Executes a batch of transactions based on the specified execution type.\n    /// @param executionCalldata The calldata for a batch of transactions.\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    function _handleBatchExecution(bytes calldata executionCalldata, ExecType execType) internal {\n        Execution[] calldata executions = executionCalldata.decodeBatch();\n        if (execType == EXECTYPE_DEFAULT) _executeBatchNoReturndata(executions);\n        else if (execType == EXECTYPE_TRY) _tryExecuteBatch(executions);\n        else revert UnsupportedExecType(execType);\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    function _handleDelegateCallExecution(bytes calldata executionCalldata, ExecType execType) internal {\n        (address delegate, bytes calldata callData) = executionCalldata.decodeDelegateCall();\n        if (execType == EXECTYPE_DEFAULT) _executeDelegatecallNoReturndata(delegate, callData);\n        else if (execType == EXECTYPE_TRY) {\n            (bool success, bytes memory result) = _tryExecuteDelegatecall(delegate, callData);\n            if (!success) emit TryDelegateCallUnsuccessful(callData, result);\n        } else revert UnsupportedExecType(execType);\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    /// @return returnData An array containing the execution result. In the case of a single transaction, the array contains one element.\n    function _handleSingleExecutionAndReturnData(bytes calldata executionCalldata, ExecType execType) internal returns (bytes[] memory returnData) {\n        (address target, uint256 value, bytes calldata callData) = executionCalldata.decodeSingle();\n        returnData = new bytes[](1);\n        bool success;\n        // check if execType is revert(default) or try\n        if (execType == EXECTYPE_DEFAULT) {\n            returnData[0] = _execute(target, value, callData);\n        } else if (execType == EXECTYPE_TRY) {\n            (success, returnData[0]) = _tryExecute(target, value, callData);\n            if (!success) emit TryExecuteUnsuccessful(callData, returnData[0]);\n        } else {\n            revert UnsupportedExecType(execType);\n        }\n    }\n\n    /// @dev Executes a batch of transactions based on the specified execution type.\n    /// @param executionCalldata The calldata for a batch of transactions.\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    /// @return returnData An array containing the execution results for each transaction in the batch.\n    function _handleBatchExecutionAndReturnData(bytes calldata executionCalldata, ExecType execType) internal returns (bytes[] memory returnData) {\n        Execution[] calldata executions = executionCalldata.decodeBatch();\n        if (execType == EXECTYPE_DEFAULT) returnData = _executeBatch(executions);\n        else if (execType == EXECTYPE_TRY) returnData = _tryExecuteBatch(executions);\n        else revert UnsupportedExecType(execType);\n    }\n\n    /// @dev Executes a single transaction based on the specified execution type.\n    /// @param executionCalldata The calldata containing the transaction details (target address, value, and data).\n    /// @param execType The execution type, which can be DEFAULT (revert on failure) or TRY (return on failure).\n    /// @return returnData An array containing the result of the delegatecall execution.\n    function _handleDelegateCallExecutionAndReturnData(\n        bytes calldata executionCalldata,\n        ExecType execType\n    ) internal returns (bytes[] memory returnData) {\n        (address delegate, bytes calldata callData) = executionCalldata.decodeDelegateCall();\n        returnData = new bytes[](1);\n        bool success;\n        if (execType == EXECTYPE_DEFAULT) {\n            returnData[0] = _executeDelegatecall(delegate, callData);\n        } else if (execType == EXECTYPE_TRY) {\n            (success, returnData[0]) = _tryExecuteDelegatecall(delegate, callData);\n            if (!success) emit TryDelegateCallUnsuccessful(callData, returnData[0]);\n        } else revert UnsupportedExecType(execType);\n    }\n}\n"},"contracts/interfaces/modules/IValidator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IValidator is IModule {\n    /// @notice Validates a user operation as per ERC-4337 standard requirements.\n    /// @dev Should ensure that the signature and nonce are verified correctly before the transaction is allowed to proceed.\n    /// The function returns a status code indicating validation success or failure.\n    /// @param userOp The user operation containing transaction details to be validated.\n    /// @param userOpHash The hash of the user operation data, used for verifying the signature.\n    /// @return status The result of the validation process, typically indicating success or the type of failure.\n    function validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external returns (uint256);\n\n    /// @notice Verifies a signature against a hash, using the sender's address as a contextual check.\n    /// @dev Used to confirm the validity of a signature against the specific conditions set by the sender.\n    /// @param sender The address from which the operation was initiated, adding an additional layer of validation against the signature.\n    /// @param hash The hash of the data signed.\n    /// @param data The signature data to validate.\n    /// @return magicValue A bytes4 value that corresponds to the ERC-1271 standard, indicating the validity of the signature.\n    function isValidSignatureWithSender(address sender, bytes32 hash, bytes calldata data) external view returns (bytes4);\n}\n"},"contracts/types/Constants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n// Magic value for ERC-1271 valid signature\nbytes4 constant ERC1271_MAGICVALUE = 0x1626ba7e;\n\n// Value indicating an invalid ERC-1271 signature\nbytes4 constant ERC1271_INVALID = 0xFFFFFFFF;\n\n// Value indicating successful validation\nuint256 constant VALIDATION_SUCCESS = 0;\n\n// Value indicating failed validation\nuint256 constant VALIDATION_FAILED = 1;\n\n// Module type identifier for Multitype install\nuint256 constant MODULE_TYPE_MULTI = 0;\n\n// Module type identifier for validators\nuint256 constant MODULE_TYPE_VALIDATOR = 1;\n\n// Module type identifier for executors\nuint256 constant MODULE_TYPE_EXECUTOR = 2;\n\n// Module type identifier for fallback handlers\nuint256 constant MODULE_TYPE_FALLBACK = 3;\n\n// Module type identifier for hooks\nuint256 constant MODULE_TYPE_HOOK = 4;\n\nstring constant MODULE_ENABLE_MODE_NOTATION = \"ModuleEnableMode(address module,uint256 moduleType,bytes32 userOpHash,bytes32 initDataHash)\";\nbytes32 constant MODULE_ENABLE_MODE_TYPE_HASH = keccak256(bytes(MODULE_ENABLE_MODE_NOTATION));\n\n// Validation modes\nbytes1 constant MODE_VALIDATION = 0x00;\nbytes1 constant MODE_MODULE_ENABLE = 0x01;\n\nbytes4 constant SUPPORTS_ERC7739 = 0x77390000;\nbytes4 constant SUPPORTS_ERC7739_V1 = 0x77390001;"},"contracts/lib/ModeLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n/// @title ModeLib\n/// @author zeroknots.eth | rhinestone.wtf\n/// To allow smart accounts to be very simple, but allow for more complex execution, A custom mode\n/// encoding is used.\n///    Function Signature of execute function:\n///           function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n/// This allows for a single bytes32 to be used to encode the execution mode, calltype, execType and\n/// context.\n/// NOTE: Simple Account implementations only have to scope for the most significant byte. Account  that\n/// implement\n/// more complex execution modes may use the entire bytes32.\n///\n/// |--------------------------------------------------------------------|\n/// | CALLTYPE  | EXECTYPE  |   UNUSED   | ModeSelector  |  ModePayload  |\n/// |--------------------------------------------------------------------|\n/// | 1 byte    | 1 byte    |   4 bytes  | 4 bytes       |   22 bytes    |\n/// |--------------------------------------------------------------------|\n///\n/// CALLTYPE: 1 byte\n/// CallType is used to determine how the executeCalldata paramter of the execute function has to be\n/// decoded.\n/// It can be either single, batch or delegatecall. In the future different calls could be added.\n/// CALLTYPE can be used by a validation module to determine how to decode <userOp.callData[36:]>.\n///\n/// EXECTYPE: 1 byte\n/// ExecType is used to determine how the account should handle the execution.\n/// It can indicate if the execution should revert on failure or continue execution.\n/// In the future more execution modes may be added.\n/// Default Behavior (EXECTYPE = 0x00) is to revert on a single failed execution. If one execution in\n/// a batch fails, the entire batch is reverted\n///\n/// UNUSED: 4 bytes\n/// Unused bytes are reserved for future use.\n///\n/// ModeSelector: bytes4\n/// The \"optional\" mode selector can be used by account vendors, to implement custom behavior in\n/// their accounts.\n/// the way a ModeSelector is to be calculated is bytes4(keccak256(\"vendorname.featurename\"))\n/// this is to prevent collisions between different vendors, while allowing innovation and the\n/// development of new features without coordination between ERC-7579 implementing accounts\n///\n/// ModePayload: 22 bytes\n/// Mode payload is used to pass additional data to the smart account execution, this may be\n/// interpreted depending on the ModeSelector\n///\n/// ExecutionCallData: n bytes\n/// single, delegatecall or batch exec abi.encoded as bytes\n\n// Custom type for improved developer experience\ntype ExecutionMode is bytes32;\n\ntype CallType is bytes1;\n\ntype ExecType is bytes1;\n\ntype ModeSelector is bytes4;\n\ntype ModePayload is bytes22;\n\n// Default CallType\nCallType constant CALLTYPE_SINGLE = CallType.wrap(0x00);\n// Batched CallType\nCallType constant CALLTYPE_BATCH = CallType.wrap(0x01);\n\nCallType constant CALLTYPE_STATIC = CallType.wrap(0xFE);\n\n// @dev Implementing delegatecall is OPTIONAL!\n// implement delegatecall with extreme care.\nCallType constant CALLTYPE_DELEGATECALL = CallType.wrap(0xFF);\n\n// @dev default behavior is to revert on failure\n// To allow very simple accounts to use mode encoding, the default behavior is to revert on failure\n// Since this is value 0x00, no additional encoding is required for simple accounts\nExecType constant EXECTYPE_DEFAULT = ExecType.wrap(0x00);\n// @dev account may elect to change execution behavior. For example \"try exec\" / \"allow fail\"\nExecType constant EXECTYPE_TRY = ExecType.wrap(0x01);\n\nModeSelector constant MODE_DEFAULT = ModeSelector.wrap(bytes4(0x00000000));\n// Example declaration of a custom mode selector\nModeSelector constant MODE_OFFSET = ModeSelector.wrap(bytes4(keccak256(\"default.mode.offset\")));\n\n/// @dev ModeLib is a helper library to encode/decode ModeCodes\nlibrary ModeLib {\n    function decode(\n        ExecutionMode mode\n    ) internal pure returns (CallType _calltype, ExecType _execType, ModeSelector _modeSelector, ModePayload _modePayload) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n            _modeSelector := shl(48, mode)\n            _modePayload := shl(80, mode)\n        }\n    }\n\n    function decodeBasic(ExecutionMode mode) internal pure returns (CallType _calltype, ExecType _execType) {\n        assembly {\n            _calltype := mode\n            _execType := shl(8, mode)\n        }\n    }\n\n    function encode(CallType callType, ExecType execType, ModeSelector mode, ModePayload payload) internal pure returns (ExecutionMode) {\n        return ExecutionMode.wrap(bytes32(abi.encodePacked(callType, execType, bytes4(0), ModeSelector.unwrap(mode), payload)));\n    }\n\n    function encodeSimpleBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeSimpleSingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_DEFAULT, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTrySingle() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_SINGLE, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeTryBatch() internal pure returns (ExecutionMode mode) {\n        mode = encode(CALLTYPE_BATCH, EXECTYPE_TRY, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function encodeCustom(CallType callType, ExecType execType) internal pure returns (ExecutionMode mode) {\n        mode = encode(callType, execType, MODE_DEFAULT, ModePayload.wrap(0x00));\n    }\n\n    function getCallType(ExecutionMode mode) internal pure returns (CallType calltype) {\n        assembly {\n            calltype := mode\n        }\n    }\n}\n\nusing { _eqModeSelector as == } for ModeSelector global;\nusing { _eqCallType as == } for CallType global;\nusing { _uneqCallType as != } for CallType global;\nusing { _eqExecType as == } for ExecType global;\n\nfunction _eqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) == CallType.unwrap(b);\n}\n\nfunction _uneqCallType(CallType a, CallType b) pure returns (bool) {\n    return CallType.unwrap(a) != CallType.unwrap(b);\n}\n\nfunction _eqExecType(ExecType a, ExecType b) pure returns (bool) {\n    return ExecType.unwrap(a) == ExecType.unwrap(b);\n}\n\n//slither-disable-next-line dead-code\nfunction _eqModeSelector(ModeSelector a, ModeSelector b) pure returns (bool) {\n    return ModeSelector.unwrap(a) == ModeSelector.unwrap(b);\n}\n"},"contracts/lib/NonceLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\nimport { MODE_MODULE_ENABLE } from \"../types/Constants.sol\";\n\n/**\n    Nonce structure\n    [3 bytes empty][1 bytes validation mode][20 bytes validator][8 bytes nonce]\n*/\n\nlibrary NonceLib {\n    /// @dev Parses validator address out of nonce\n    /// @param nonce The nonce\n    /// @return validator\n    function getValidator(uint256 nonce) internal pure returns (address validator) {\n        assembly {\n            validator := shr(96, shl(32, nonce))\n        }\n    }\n\n    /// @dev Detects if Validaton Mode is Module Enable Mode\n    /// @param nonce The nonce\n    /// @return res boolean result, true if it is the Module Enable Mode\n    function isModuleEnableMode(uint256 nonce) internal pure returns (bool res) {\n        assembly {\n            let vmode := byte(3, nonce)\n            res := eq(shl(248, vmode), MODE_MODULE_ENABLE)\n        }\n    }\n}\n"},"node_modules/sentinellist/src/SentinelList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Sentinel address\naddress constant SENTINEL = address(0x1);\n// Zero address\naddress constant ZERO_ADDRESS = address(0x0);\n\n/**\n * @title SentinelListLib\n * @dev Library for managing a linked list of addresses\n * @author Rhinestone\n */\nlibrary SentinelListLib {\n    // Struct to hold the linked list\n    struct SentinelList {\n        mapping(address => address) entries;\n    }\n\n    error LinkedList_AlreadyInitialized();\n    error LinkedList_InvalidPage();\n    error LinkedList_InvalidEntry(address entry);\n    error LinkedList_EntryAlreadyInList(address entry);\n\n    /**\n     * Initialize the linked list\n     *\n     * @param self The linked list\n     */\n    function init(SentinelList storage self) internal {\n        if (alreadyInitialized(self)) revert LinkedList_AlreadyInitialized();\n        self.entries[SENTINEL] = SENTINEL;\n    }\n\n    /**\n     * Check if the linked list is already initialized\n     *\n     * @param self The linked list\n     *\n     * @return bool True if the linked list is already initialized\n     */\n    function alreadyInitialized(SentinelList storage self) internal view returns (bool) {\n        return self.entries[SENTINEL] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get the next entry in the linked list\n     *\n     * @param self The linked list\n     * @param entry The current entry\n     *\n     * @return address The next entry\n     */\n    function getNext(SentinelList storage self, address entry) internal view returns (address) {\n        if (entry == ZERO_ADDRESS) {\n            revert LinkedList_InvalidEntry(entry);\n        }\n        return self.entries[entry];\n    }\n\n    /**\n     * Push a new entry to the linked list\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function push(SentinelList storage self, address newEntry) internal {\n        if (newEntry == ZERO_ADDRESS || newEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(newEntry);\n        }\n        if (self.entries[newEntry] != ZERO_ADDRESS) revert LinkedList_EntryAlreadyInList(newEntry);\n        self.entries[newEntry] = self.entries[SENTINEL];\n        self.entries[SENTINEL] = newEntry;\n    }\n\n    /**\n     * Safe push a new entry to the linked list\n     * @dev This ensures that the linked list is initialized and initializes it if it is not\n     *\n     * @param self The linked list\n     * @param newEntry The new entry\n     */\n    function safePush(SentinelList storage self, address newEntry) internal {\n        if (!alreadyInitialized({ self: self })) {\n            init({ self: self });\n        }\n        push({ self: self, newEntry: newEntry });\n    }\n\n    /**\n     * Pop an entry from the linked list\n     *\n     * @param self The linked list\n     * @param prevEntry The entry before the entry to pop\n     * @param popEntry The entry to pop\n     */\n    function pop(SentinelList storage self, address prevEntry, address popEntry) internal {\n        if (popEntry == ZERO_ADDRESS || popEntry == SENTINEL) {\n            revert LinkedList_InvalidEntry(prevEntry);\n        }\n        if (self.entries[prevEntry] != popEntry) revert LinkedList_InvalidEntry(popEntry);\n        self.entries[prevEntry] = self.entries[popEntry];\n        self.entries[popEntry] = ZERO_ADDRESS;\n    }\n\n    /**\n     * Pop all entries from the linked list\n     *\n     * @param self The linked list\n     */\n    function popAll(SentinelList storage self) internal {\n        address next = self.entries[SENTINEL];\n        while (next != ZERO_ADDRESS) {\n            address current = next;\n            next = self.entries[next];\n            self.entries[current] = ZERO_ADDRESS;\n        }\n    }\n\n    /**\n     * Check if the linked list contains an entry\n     *\n     * @param self The linked list\n     * @param entry The entry to check\n     *\n     * @return bool True if the linked list contains the entry\n     */\n    function contains(SentinelList storage self, address entry) internal view returns (bool) {\n        return SENTINEL != entry && self.entries[entry] != ZERO_ADDRESS;\n    }\n\n    /**\n     * Get all entries in the linked list\n     *\n     * @param self The linked list\n     * @param start The start entry\n     * @param pageSize The page size\n     *\n     * @return array All entries in the linked list\n     * @return next The next entry\n     */\n    function getEntriesPaginated(\n        SentinelList storage self,\n        address start,\n        uint256 pageSize\n    )\n        internal\n        view\n        returns (address[] memory array, address next)\n    {\n        if (start != SENTINEL && !contains(self, start)) revert LinkedList_InvalidEntry(start);\n        if (pageSize == 0) revert LinkedList_InvalidPage();\n        // Init array with max page size\n        array = new address[](pageSize);\n\n        // Populate return array\n        uint256 entryCount = 0;\n        next = self.entries[start];\n        while (next != ZERO_ADDRESS && next != SENTINEL && entryCount < pageSize) {\n            array[entryCount] = next;\n            next = self.entries[next];\n            entryCount++;\n        }\n\n        /**\n         * Because of the argument validation, we can assume that the loop will always iterate over\n         * the valid entry list values\n         *       and the `next` variable will either be an enabled entry or a sentinel address\n         * (signalling the end).\n         *\n         *       If we haven't reached the end inside the loop, we need to set the next pointer to\n         * the last element of the entry array\n         *       because the `next` variable (which is a entry by itself) acting as a pointer to the\n         * start of the next page is neither\n         *       incSENTINELrent page, nor will it be included in the next one if you pass it as a\n         * start.\n         */\n        if (next != SENTINEL && entryCount > 0) {\n            next = array[entryCount - 1];\n        }\n        // Set correct size of returned array\n        // solhint-disable-next-line no-inline-assembly\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(array, entryCount)\n        }\n    }\n}\n"},"node_modules/solady/src/utils/CallContextChecker.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Call context checker mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/CallContextChecker.sol)\ncontract CallContextChecker {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The call is from an unauthorized call context.\n    error UnauthorizedCallContext();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         IMMUTABLES                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev For checking if the context is a delegate call.\n    ///\n    /// Note: To enable use cases with an immutable default implementation in the bytecode,\n    /// (see: ERC6551Proxy), we don't require that the proxy address must match the\n    /// value stored in the implementation slot, which may not be initialized.\n    uint256 private immutable __self = uint256(uint160(address(this)));\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    CALL CONTEXT CHECKS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // A proxy call can be either via a `delegatecall` to an implementation,\n    // or a 7702 call on an authority that points to a delegation.\n\n    /// @dev Returns whether the current call context is on a EIP7702 authority\n    /// (i.e. externally owned account).\n    function _onEIP7702Authority() internal view virtual returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            extcodecopy(address(), 0x00, 0x00, 0x20)\n            // Note: Checking that it starts with hex\"ef01\" is the most general and futureproof.\n            // 7702 bytecode is `abi.encodePacked(hex\"ef01\", uint8(version), address(delegation))`.\n            result := eq(0xef01, shr(240, mload(0x00)))\n        }\n    }\n\n    /// @dev Returns whether the current call context is on the implementation itself.\n    function _onImplementation() internal view virtual returns (bool) {\n        return __self == uint160(address(this));\n    }\n\n    /// @dev Requires that the current call context is performed via a EIP7702 authority.\n    function _checkOnlyEIP7702Authority() internal view virtual {\n        if (!_onEIP7702Authority()) _revertUnauthorizedCallContext();\n    }\n\n    /// @dev Requires that the current call context is performed via a proxy.\n    function _checkOnlyProxy() internal view virtual {\n        if (_onImplementation()) _revertUnauthorizedCallContext();\n    }\n\n    /// @dev Requires that the current call context is NOT performed via a proxy.\n    /// This is the opposite of `checkOnlyProxy`.\n    function _checkNotDelegated() internal view virtual {\n        if (!_onImplementation()) _revertUnauthorizedCallContext();\n    }\n\n    /// @dev Requires that the current call context is performed via a EIP7702 authority.\n    modifier onlyEIP7702Authority() virtual {\n        _checkOnlyEIP7702Authority();\n        _;\n    }\n\n    /// @dev Requires that the current call context is performed via a proxy.\n    modifier onlyProxy() virtual {\n        _checkOnlyProxy();\n        _;\n    }\n\n    /// @dev Requires that the current call context is NOT performed via a proxy.\n    /// This is the opposite of `onlyProxy`.\n    modifier notDelegated() virtual {\n        _checkNotDelegated();\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function _revertUnauthorizedCallContext() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n            revert(0x1c, 0x04)\n        }\n    }\n}\n"},"contracts/types/DataTypes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution\n/// @notice Struct to encapsulate execution data for a transaction\nstruct Execution {\n    /// @notice The target address for the transaction\n    address target;\n    /// @notice The value in wei to send with the transaction\n    uint256 value;\n    /// @notice The calldata for the transaction\n    bytes callData;\n}\n"},"contracts/interfaces/IERC4337Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title Nexus - IERC4337Account\n/// @notice This interface defines the necessary validation and execution methods for smart accounts under the ERC-4337 standard.\n/// @dev Provides a structure for implementing custom validation logic and execution methods that comply with ERC-4337 \"account abstraction\" specs.\n/// The validation method ensures proper signature and nonce verification before proceeding with transaction execution, critical for securing userOps.\n/// Also allows for the optional definition of an execution method to handle transactions post-validation, enhancing flexibility.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IERC4337Account {\n    /// Validate user's signature and nonce\n    /// the entryPoint will make the call to the recipient only if this validation call returns successfully.\n    /// signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n    /// This allows making a \"simulation call\" without a valid signature\n    /// Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n    ///\n    /// @dev ERC-4337-v-0.7 validation stage\n    /// @dev Must validate caller is the entryPoint.\n    ///      Must validate the signature and nonce\n    /// @param userOp              - The user operation that is about to be executed.\n    /// @param userOpHash          - Hash of the user's request data. can be used as the basis for signature.\n    /// @param missingAccountFunds - Missing funds on the account's deposit in the entrypoint.\n    ///                              This is the minimum amount to transfer to the sender(entryPoint) to be\n    ///                              able to make the call. The excess is left as a deposit in the entrypoint\n    ///                              for future calls. Can be withdrawn anytime using \"entryPoint.withdrawTo()\".\n    ///                              In case there is a paymaster in the request (or the current deposit is high\n    ///                              enough), this value will be zero.\n    /// @return validationData       - Packaged ValidationData structure. use `_packValidationData` and\n    ///                              `_unpackValidationData` to encode and decode.\n    ///                              <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n    ///                                 otherwise, an address of an \"authorizer\" contract.\n    ///                              <6-byte> validUntil - Last timestamp this operation is valid. 0 for \"indefinite\"\n    ///                              <6-byte> validAfter - First timestamp this operation is valid\n    ///                                                    If an account doesn't use time-range, it is enough to\n    ///                                                    return SIG_VALIDATION_FAILED value (1) for signature failure.\n    ///                              Note that the validation code cannot use block.timestamp (or block.number) directly.\n    function validateUserOp(\n        PackedUserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n\n    /// Account may implement this execute method.\n    /// passing this methodSig at the beginning of callData will cause the entryPoint to pass the\n    /// full UserOp (and hash)\n    /// to the account.\n    /// The account should skip the methodSig, and use the callData (and optionally, other UserOp\n    /// fields)\n    /// @dev ERC-4337-v-0.7 optional execution path\n    /// @param userOp              - The operation that was just validated.\n    /// @param userOpHash          - Hash of the user's request data.\n    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external payable;\n}\n"},"contracts/interfaces/IERC7579Account.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IAccountConfig } from \"./base/IAccountConfig.sol\";\nimport { IExecutionHelper } from \"./base/IExecutionHelper.sol\";\nimport { IModuleManager } from \"./base/IModuleManager.sol\";\n\n/// @title Nexus - IERC7579Account\n/// @notice This interface integrates the functionalities required for a modular smart account compliant with ERC-7579 and ERC-4337 standards.\n/// @dev Combines configurations and operational management for smart accounts, bridging IAccountConfig, IExecutionHelper, and IModuleManager.\n/// Interfaces designed to support the comprehensive management of smart account operations including execution management and modular configurations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IERC7579Account is IAccountConfig, IExecutionHelper, IModuleManager {\n    /// @dev Validates a smart account signature according to ERC-1271 standards.\n    /// This method may delegate the call to a validator module to check the signature.\n    /// @param hash The hash of the data being validated.\n    /// @param data The signed data to validate.\n    function isValidSignature(bytes32 hash, bytes calldata data) external view returns (bytes4);\n}\n"},"contracts/interfaces/INexusEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { PackedUserOperation } from \"account-abstraction/interfaces/PackedUserOperation.sol\";\n\n/// @title Nexus - INexus Events and Errors\n/// @notice Defines common errors for the Nexus smart account management interface.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface INexusEventsAndErrors {\n    /// @notice Emitted when a user operation is executed from `executeUserOp`\n    /// @param userOp The user operation that was executed.\n    /// @param innerCallRet The return data from the inner call execution.\n    event Executed(PackedUserOperation userOp, bytes innerCallRet);\n\n    /// @notice Error thrown when an unsupported ModuleType is requested.\n    /// @param moduleTypeId The ID of the unsupported module type.\n    error UnsupportedModuleType(uint256 moduleTypeId);\n\n    /// @notice Error thrown on failed execution.\n    error ExecutionFailed();\n\n    /// @notice Error thrown when the Factory fails to initialize the account with posted bootstrap data.\n    error NexusInitializationFailed();\n\n    /// @notice Error thrown when a zero address is provided as the Entry Point address.\n    error EntryPointCanNotBeZero();\n\n    /// @notice Error thrown when the provided implementation address is invalid.\n    error InvalidImplementationAddress();\n\n    /// @notice Error thrown when the provided implementation address is not a contract.\n    error ImplementationIsNotAContract();\n\n    /// @notice Error thrown when an inner call fails.\n    error InnerCallFailed();\n\n    /// @notice Error thrown when attempted to emergency-uninstall a hook\n    error EmergencyTimeLockNotExpired();\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IEntryPoint.sol":{"content":"/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./PackedUserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request.\n     * @param userOpHash    - Unique identifier for the request (hash its entire content, except signature).\n     * @param sender        - The account that generates this request.\n     * @param paymaster     - If non-null, the paymaster that pays for this request.\n     * @param nonce         - The nonce value from the request.\n     * @param success       - True if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - Actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - Total gas used by this UserOperation (including preVerification, creation,\n     *                        validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * Account \"sender\" was deployed.\n     * @param userOpHash - The userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender     - The account that is deployed\n     * @param factory    - The factory used to deploy this account (in the initCode)\n     * @param paymaster  - The paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * An event emitted if the UserOperation Paymaster's \"postOp\" call reverted with non-zero length.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     * @param revertReason - The return bytes from the (reverted) call to \"callData\".\n     */\n    event PostOpRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * UserOp consumed more than prefund. The UserOperation is reverted, and no refund is made.\n     * @param userOpHash   - The request unique identifier.\n     * @param sender       - The sender of this request.\n     * @param nonce        - The nonce used in the request.\n     */\n    event UserOperationPrefundTooLow(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce\n    );\n\n    /**\n     * An event emitted by handleOps(), before starting the execution loop.\n     * Any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * Signature aggregator used by the following UserOperationEvents within this bundle.\n     * @param aggregator - The aggregator used for the following UserOperationEvents.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * A custom revert error of handleOps, to identify the offending op.\n     * Should be caught in off-chain handleOps simulation and not happen on-chain.\n     * Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     * NOTE: If simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. The string starts with a unique code \"AAmn\",\n     *                  where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *                  so a failure can be attributed to the correct entity.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * A custom revert error of handleOps, to report a revert by account or paymaster.\n     * @param opIndex - Index into the array of ops to the failed one (in simulateValidation, this is always zero).\n     * @param reason  - Revert reason. see FailedOp(uint256,string), above\n     * @param inner   - data from inner cought revert reason\n     * @dev note that inner is truncated to 2048 bytes\n     */\n    error FailedOpWithRevert(uint256 opIndex, string reason, bytes inner);\n\n    error PostOpReverted(bytes returnData);\n\n    /**\n     * Error case when a signature aggregator fails to verify the aggregated signature it had created.\n     * @param aggregator The aggregator that failed to verify the signature\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    // Return value of getSenderAddress.\n    error SenderAddressResult(address sender);\n\n    // UserOps handled, per aggregator.\n    struct UserOpsPerAggregator {\n        PackedUserOperation[] userOps;\n        // Aggregator address\n        IAggregator aggregator;\n        // Aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperations.\n     * No signature aggregator is used.\n     * If any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops         - The operations to execute.\n     * @param beneficiary - The address to receive the fees.\n     */\n    function handleOps(\n        PackedUserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator - The operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts).\n     * @param beneficiary      - The address to receive the fees.\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Generate a request Id - unique identifier for this request.\n     * The request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     * @param userOp - The user operation to generate the request ID for.\n     * @return hash the hash of this UserOperation\n     */\n    function getUserOpHash(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Gas and return values during simulation.\n     * @param preOpGas         - The gas used for validation (including preValidationGas)\n     * @param prefund          - The required prefund for this operation\n     * @param accountValidationData   - returned validationData from account.\n     * @param paymasterValidationData - return validationData from paymaster.\n     * @param paymasterContext - Returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        uint256 accountValidationData;\n        uint256 paymasterValidationData;\n        bytes paymasterContext;\n    }\n\n    /**\n     * Returned aggregated signature info:\n     * The aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     * Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * This method always revert, and returns the address in SenderAddressResult error\n     * @param initCode - The constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    error DelegateAndRevert(bool success, bytes ret);\n\n    /**\n     * Helper method for dry-run testing.\n     * @dev calling this method, the EntryPoint will make a delegatecall to the given data, and report (via revert) the result.\n     *  The method always revert, so is only useful off-chain for dry run calls, in cases where state-override to replace\n     *  actual EntryPoint code is less convenient.\n     * @param target a target contract to make a delegatecall from entrypoint\n     * @param data data to pass to target in a delegatecall\n     */\n    function delegateAndRevert(address target, bytes calldata data) external;\n}\n"},"contracts/interfaces/base/IBaseAccount.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IBaseAccountEventsAndErrors } from \"./IBaseAccountEventsAndErrors.sol\";\n\n/// @title Nexus - IBaseAccount\n/// @notice Interface for the BaseAccount functionalities compliant with ERC-7579 and ERC-4337.\n/// @dev Interface for organizing the base functionalities using the Nexus suite.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IBaseAccount is IBaseAccountEventsAndErrors {\n    /// @notice Adds deposit to the EntryPoint to fund transactions.\n    function addDeposit() external payable;\n\n    /// @notice Withdraws ETH from the EntryPoint to a specified address.\n    /// @param to The address to receive the withdrawn funds.\n    /// @param amount The amount to withdraw.\n    function withdrawDepositTo(address to, uint256 amount) external payable;\n\n    /// @notice Gets the nonce for a particular key.\n    /// @param key The nonce key.\n    /// @return The nonce associated with the key.\n    function nonce(uint192 key) external view returns (uint256);\n\n    /// @notice Returns the current deposit balance of this account on the EntryPoint.\n    /// @return The current balance held at the EntryPoint.\n    function getDeposit() external view returns (uint256);\n\n    /// @notice Retrieves the address of the EntryPoint contract, currently using version 0.7.\n    /// @return The address of the EntryPoint contract.\n    function entryPoint() external view returns (address);\n}\n"},"contracts/base/Storage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IStorage } from \"../interfaces/base/IStorage.sol\";\n\n/// @title Nexus - Storage\n/// @notice Manages isolated storage spaces for Modular Smart Account in compliance with ERC-7201 standard to ensure collision-resistant storage.\n/// @dev Implements the ERC-7201 namespaced storage pattern to maintain secure and isolated storage sections for different states within Nexus suite.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ncontract Storage is IStorage {\n    /// @custom:storage-location erc7201:biconomy.storage.Nexus\n    /// ERC-7201 namespaced via `keccak256(abi.encode(uint256(keccak256(bytes(\"biconomy.storage.Nexus\"))) - 1)) & ~bytes32(uint256(0xff));`\n    bytes32 private constant _STORAGE_LOCATION = 0x0bb70095b32b9671358306b0339b4c06e7cbd8cb82505941fba30d1eb5b82f00;\n\n    /// @dev Utilizes ERC-7201's namespaced storage pattern for isolated storage access. This method computes\n    /// the storage slot based on a predetermined location, ensuring collision-resistant storage for contract states.\n    /// @custom:storage-location ERC-7201 formula applied to \"biconomy.storage.Nexus\", facilitating unique\n    /// namespace identification and storage segregation, as detailed in the specification.\n    /// @return $ The proxy to the `AccountStorage` struct, providing a reference to the namespaced storage slot.\n    function _getAccountStorage() internal pure returns (AccountStorage storage $) {\n        assembly {\n            $.slot := _STORAGE_LOCATION\n        }\n    }\n}\n"},"contracts/interfaces/modules/IHook.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Hook Management Interface\n/// @notice Provides methods for pre-checks and post-checks of transactions to ensure conditions and state consistency.\n/// @dev Defines two critical lifecycle hooks in the transaction process: `preCheck` and `postCheck`.\n/// These methods facilitate validating conditions prior to execution and verifying state changes afterwards, respectively.\ninterface IHook is IModule {\n    /// @notice Performs checks before a transaction is executed, potentially modifying the transaction context.\n    /// @dev This method is called before the execution of a transaction to validate and possibly adjust execution context.\n    /// @param msgSender The original sender of the transaction.\n    /// @param msgValue The amount of wei sent with the call.\n    /// @param msgData The calldata of the transaction.\n    /// @return hookData Data that may be used or modified throughout the transaction lifecycle, passed to `postCheck`.\n    function preCheck(address msgSender, uint256 msgValue, bytes calldata msgData) external returns (bytes memory hookData);\n\n    /// @notice Performs checks after a transaction is executed to ensure state consistency and log results.\n    /// @dev This method is called after the execution of a transaction to verify and react to the execution outcome.\n    /// @param hookData Data returned from `preCheck`, containing execution context or modifications.\n    function postCheck(bytes calldata hookData) external;\n}\n"},"contracts/interfaces/modules/IModule.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Nexus - ERC-7579 Module Base Interface\n/// @notice Interface for module management in smart accounts, complying with ERC-7579 specifications.\n/// @dev Defines the lifecycle hooks and checks for modules within the smart account architecture.\n/// This interface includes methods for installing, uninstalling, and verifying module types and initialization status.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModule {\n    /// @notice Installs the module with necessary initialization data.\n    /// @dev Reverts if the module is already initialized.\n    /// @param data Arbitrary data required for initializing the module during `onInstall`.\n    function onInstall(bytes calldata data) external;\n\n    /// @notice Uninstalls the module and allows for cleanup via arbitrary data.\n    /// @dev Reverts if any issues occur that prevent clean uninstallation.\n    /// @param data Arbitrary data required for deinitializing the module during `onUninstall`.\n    function onUninstall(bytes calldata data) external;\n\n    /// @notice Determines if the module matches a specific module type.\n    /// @dev Should return true if the module corresponds to the type ID, false otherwise.\n    /// @param moduleTypeId Numeric ID of the module type as per ERC-7579 specifications.\n    /// @return True if the module is of the specified type, false otherwise.\n    function isModuleType(uint256 moduleTypeId) external view returns (bool);\n\n    /// @notice Checks if the module has been initialized for a specific smart account.\n    /// @dev Returns true if initialized, false otherwise.\n    /// @param smartAccount Address of the smart account to check for initialization status.\n    /// @return True if the module is initialized for the given smart account, false otherwise.\n    function isInitialized(address smartAccount) external view returns (bool);\n}\n"},"contracts/interfaces/modules/IExecutor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Nexus - IExecutor Interface\n/// @notice Defines the interface for Executor modules within the Nexus Smart Account framework, compliant with the ERC-7579 standard.\n/// @dev Extends IModule to include functionalities specific to execution modules.\n/// This interface is future-proof, allowing for expansion and integration of advanced features in subsequent versions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IExecutor is IModule {\n    // Future methods for execution management will be defined here to accommodate evolving requirements.\n}\n"},"contracts/interfaces/modules/IFallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModule } from \"./IModule.sol\";\n\n/// @title Nexus - IFallback Interface\n/// @notice Defines the interface for Fallback modules within the Nexus Smart Account framework, compliant with the ERC-7579 standard.\n/// @dev Extends IModule to include functionalities specific to fallback modules.\n/// This interface is future-proof, allowing for expansion and integration of advanced features in subsequent versions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IFallback is IModule {\n    // Future methods for fallback management will be defined here to accommodate evolving blockchain technologies.\n}\n"},"contracts/lib/local/LocalCallDataParserLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\nlibrary LocalCallDataParserLib {\n    /// @dev Parses the `userOp.signature` to extract the module type, module initialization data,\n    ///      enable mode signature, and user operation signature. The `userOp.signature` must be\n    ///      encoded in a specific way to be parsed correctly.\n    /// @param packedData The packed signature data, typically coming from `userOp.signature`.\n    /// @return module The address of the module.\n    /// @return moduleType The type of module as a `uint256`.\n    /// @return moduleInitData Initialization data specific to the module.\n    /// @return enableModeSignature Signature used to enable the module mode.\n    /// @return userOpSignature The remaining user operation signature data.\n    function parseEnableModeData(\n        bytes calldata packedData\n    )\n        internal\n        pure\n        returns (\n            address module,\n            uint256 moduleType,\n            bytes calldata moduleInitData,\n            bytes calldata enableModeSignature,\n            bytes calldata userOpSignature\n        )\n    {\n        uint256 p;\n        assembly (\"memory-safe\") {\n            p := packedData.offset\n            module := shr(96, calldataload(p))\n\n            p := add(p, 0x14)\n            moduleType := calldataload(p)\n\n            moduleInitData.length := shr(224, calldataload(add(p, 0x20)))\n            moduleInitData.offset := add(p, 0x24)\n            p := add(moduleInitData.offset, moduleInitData.length)\n\n            enableModeSignature.length := shr(224, calldataload(p))\n            enableModeSignature.offset := add(p, 0x04)\n            p := sub(add(enableModeSignature.offset, enableModeSignature.length), packedData.offset)\n        }\n        userOpSignature = packedData[p:];\n    }\n\n    /// @dev Parses the data to obtain types and initdata's for Multi Type module install mode\n    /// @param initData Multi Type module init data, abi.encoded\n    function parseMultiTypeInitData(bytes calldata initData) internal pure returns (uint256[] calldata types, bytes[] calldata initDatas) {\n        // equivalent of:\n        // (types, initDatas) = abi.decode(initData,(uint[],bytes[]))\n        assembly (\"memory-safe\") {\n            let offset := initData.offset\n            let baseOffset := offset\n            let dataPointer := add(baseOffset, calldataload(offset))\n\n            types.offset := add(dataPointer, 32)\n            types.length := calldataload(dataPointer)\n            offset := add(offset, 32)\n\n            dataPointer := add(baseOffset, calldataload(offset))\n            initDatas.offset := add(dataPointer, 32)\n            initDatas.length := calldataload(dataPointer)\n        }\n    }\n}\n"},"contracts/interfaces/base/IModuleManagerEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { CallType } from \"../../lib/ModeLib.sol\";\n\n/// @title ERC-7579 Module Manager Events and Errors Interface\n/// @notice Provides event and error definitions for actions related to module management in smart accounts.\n/// @dev Used by IModuleManager to define the events and errors associated with the installation and management of modules.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManagerEventsAndErrors {\n    /// @notice Emitted when a module is installed onto a smart account.\n    /// @param moduleTypeId The identifier for the type of module installed.\n    /// @param module The address of the installed module.\n    event ModuleInstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Emitted when a module is uninstalled from a smart account.\n    /// @param moduleTypeId The identifier for the type of module uninstalled.\n    /// @param module The address of the uninstalled module.\n    event ModuleUninstalled(uint256 moduleTypeId, address module);\n\n    /// @notice Thrown when attempting to remove the last validator.\n    error CanNotRemoveLastValidator();\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error ValidatorNotInstalled(address module);\n\n    /// @dev Thrown when there is no installed validator detected.\n    error NoValidatorInstalled();\n\n    /// @dev Thrown when the specified module address is not recognized as valid.\n    error InvalidModule(address module);\n\n    /// @dev Thrown when an invalid module type identifier is provided.\n    error InvalidModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a module that is already installed.\n    error ModuleAlreadyInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when an operation is performed by an unauthorized operator.\n    error UnauthorizedOperation(address operator);\n\n    /// @dev Thrown when there is an attempt to uninstall a module that is not installed.\n    error ModuleNotInstalled(uint256 moduleTypeId, address module);\n\n    /// @dev Thrown when a module address is set to zero.\n    error ModuleAddressCanNotBeZero();\n\n    /// @dev Thrown when a post-check fails after hook execution.\n    error HookPostCheckFailed();\n\n    /// @dev Thrown when there is an attempt to install a hook while another is already installed.\n    error HookAlreadyInstalled(address currentHook);\n\n    /// @dev Thrown when there is an attempt to install a fallback handler for a selector already having one.\n    error FallbackAlreadyInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when there is an attempt to uninstall a fallback handler for a selector that does not have one installed.\n    error FallbackNotInstalledForSelector(bytes4 selector);\n\n    /// @dev Thrown when a fallback handler fails to uninstall properly.\n    error FallbackHandlerUninstallFailed();\n\n    /// @dev Thrown when no fallback handler is available for a given selector.\n    error MissingFallbackHandler(bytes4 selector);\n\n    /// @dev Thrown when Invalid data is provided for MultiType install flow\n    error InvalidInput();\n\n    /// @dev Thrown when unable to validate Module Enable Mode signature\n    error EnableModeSigError();\n\n    /// Error thrown when account installs/uninstalls module with mismatched input `moduleTypeId`\n    error MismatchModuleTypeId(uint256 moduleTypeId);\n\n    /// @dev Thrown when there is an attempt to install a forbidden selector as a fallback handler.\n    error FallbackSelectorForbidden();\n\n    /// @dev Thrown when there is an attempt to install a fallback handler with an invalid calltype for a given selector.\n    error FallbackCallTypeInvalid();\n\n    /// @notice Error thrown when an execution with an unsupported CallType was made.\n    /// @param callType The unsupported call type.\n    error UnsupportedCallType(CallType callType);\n}\n"},"node_modules/solady/src/utils/EIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Contract for EIP-712 typed structured data hashing and signing.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EIP712.sol)\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/utils/EIP712.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/EIP712.sol)\n///\n/// @dev Note, this implementation:\n/// - Uses `address(this)` for the `verifyingContract` field.\n/// - Does NOT use the optional EIP-712 salt.\n/// - Does NOT use any EIP-712 extensions.\n/// This is for simplicity and to save gas.\n/// If you need to customize, please fork / modify accordingly.\nabstract contract EIP712 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  CONSTANTS AND IMMUTABLES                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\n    bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\n\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,address verifyingContract)\")`.\n    /// This is only used in `_hashTypedDataSansChainId`.\n    bytes32 internal constant _DOMAIN_TYPEHASH_SANS_CHAIN_ID =\n        0x91ab3d17e3a50a9d89e63fd30b92be7f5336b03b287bb946787a83a9d62a2766;\n\n    uint256 private immutable _cachedThis;\n    uint256 private immutable _cachedChainId;\n    bytes32 private immutable _cachedNameHash;\n    bytes32 private immutable _cachedVersionHash;\n    bytes32 private immutable _cachedDomainSeparator;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CONSTRUCTOR                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Cache the hashes for cheaper runtime gas costs.\n    /// In the case of upgradeable contracts (i.e. proxies),\n    /// or if the chain id changes due to a hard fork,\n    /// the domain separator will be seamlessly calculated on-the-fly.\n    constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   FUNCTIONS TO OVERRIDE                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Please override this function to return the domain name and version.\n    /// ```\n    ///     function _domainNameAndVersion()\n    ///         internal\n    ///         pure\n    ///         virtual\n    ///         returns (string memory name, string memory version)\n    ///     {\n    ///         name = \"Solady\";\n    ///         version = \"1\";\n    ///     }\n    /// ```\n    ///\n    /// Note: If the returned result may change after the contract has been deployed,\n    /// you must override `_domainNameAndVersionMayChange()` to return true.\n    function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);\n\n    /// @dev Returns if `_domainNameAndVersion()` may change\n    /// after the contract has been deployed (i.e. after the constructor).\n    /// Default: false.\n    function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     HASHING OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }\n\n    /// @dev Returns the hash of the fully encoded EIP-712 message for this domain,\n    /// given `structHash`, as defined in\n    /// https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct.\n    ///\n    /// The hash can be used together with {ECDSA-recover} to obtain the signer of a message:\n    /// ```\n    ///     bytes32 digest = _hashTypedData(keccak256(abi.encode(\n    ///         keccak256(\"Mail(address to,string contents)\"),\n    ///         mailTo,\n    ///         keccak256(bytes(mailContents))\n    ///     )));\n    ///     address signer = ECDSA.recover(digest, signature);\n    /// ```\n    function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }\n\n    /// @dev Variant of `_hashTypedData` that excludes the chain ID.\n    /// We expect that most contracts will use `_hashTypedData` as the main hash,\n    /// and `_hashTypedDataSansChainId` only occasionally for cross-chain workflows.\n    /// Thus this is optimized for smaller bytecode size over runtime gas.\n    function _hashTypedDataSansChainId(bytes32 structHash)\n        internal\n        view\n        virtual\n        returns (bytes32 digest)\n    {\n        (string memory name, string memory version) = _domainNameAndVersion();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(0x00, _DOMAIN_TYPEHASH_SANS_CHAIN_ID)\n            mstore(0x20, keccak256(add(name, 0x20), mload(name)))\n            mstore(0x40, keccak256(add(version, 0x20), mload(version)))\n            mstore(0x60, address())\n            // Compute the digest.\n            mstore(0x20, keccak256(0x00, 0x80)) // Store the domain separator.\n            mstore(0x00, 0x1901) // Store \"\\x19\\x01\".\n            mstore(0x40, structHash) // Store the struct hash.\n            digest := keccak256(0x1e, 0x42)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    EIP-5267 OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev See: https://eips.ethereum.org/EIPS/eip-5267\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the EIP-712 domain separator.\n    function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }\n\n    /// @dev Returns if the cached domain separator has been invalidated.\n    function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }\n}\n"},"node_modules/excessively-safe-call/src/ExcessivelySafeCall.sol":{"content":"// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"},"contracts/base/RegistryAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\nimport { IERC7484 } from \"../interfaces/IERC7484.sol\";\n\n/// @title RegistryAdapter\n/// @notice This contract provides an interface for interacting with an ERC-7484 compliant registry.\n/// @dev The registry feature is opt-in, allowing the smart account owner to select and trust specific attesters.\nabstract contract RegistryAdapter {\n    IERC7484 public registry;\n\n    /// @notice Emitted when a new ERC-7484 registry is configured for the account.\n    /// @param registry The configured registry contract.\n    event ERC7484RegistryConfigured(IERC7484 indexed registry);\n\n    /// @notice Modifier to check if a module meets the required attestations in the registry.\n    /// @param module The module to check.\n    /// @param moduleType The type of the module to verify in the registry.\n    modifier withRegistry(address module, uint256 moduleType) {\n        _checkRegistry(module, moduleType);\n        _;\n    }\n\n    /// @notice Configures the ERC-7484 registry and sets trusted attesters.\n    /// @param newRegistry The new registry contract to use.\n    /// @param attesters The list of attesters to trust.\n    /// @param threshold The number of attestations required.\n    function _configureRegistry(IERC7484 newRegistry, address[] calldata attesters, uint8 threshold) internal {\n        registry = newRegistry;\n        if (address(newRegistry) != address(0)) {\n            newRegistry.trustAttesters(threshold, attesters);\n        }\n        emit ERC7484RegistryConfigured(newRegistry);\n    }\n\n    /// @notice Checks the registry to ensure sufficient valid attestations for a module.\n    /// @param module The module to check.\n    /// @param moduleType The type of the module to verify in the registry.\n    /// @dev Reverts if the required attestations are not met.\n    function _checkRegistry(address module, uint256 moduleType) internal view {\n        IERC7484 moduleRegistry = registry;\n        if (address(moduleRegistry) != address(0)) {\n            // This will revert if attestations or the threshold are not met.\n            moduleRegistry.check(module, moduleType);\n        }\n    }\n}\n"},"contracts/interfaces/base/IExecutionHelper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { ExecutionMode } from \"../../lib/ModeLib.sol\";\n\nimport { IExecutionHelperEventsAndErrors } from \"./IExecutionHelperEventsAndErrors.sol\";\n\n/// @title Nexus - IExecutionHelper\n/// @notice Interface for executing transactions on behalf of smart accounts within the Nexus system.\n/// @dev Extends functionality for transaction execution with error handling as defined in IExecutionHelperEventsAndErrors.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IExecutionHelper is IExecutionHelperEventsAndErrors {\n    /// @notice Executes a transaction with specified execution mode and calldata.\n    /// @param mode The execution mode, defining how the transaction is processed.\n    /// @param executionCalldata The calldata to execute.\n    /// @dev This function ensures that the execution complies with smart account execution policies and handles errors appropriately.\n    function execute(ExecutionMode mode, bytes calldata executionCalldata) external payable;\n\n    /// @notice Allows an executor module to perform transactions on behalf of the account.\n    /// @param mode The execution mode that details how the transaction should be handled.\n    /// @param executionCalldata The transaction data to be executed.\n    /// @return returnData The result of the execution, allowing for error handling and results interpretation by the executor module.\n    function executeFromExecutor(ExecutionMode mode, bytes calldata executionCalldata) external payable returns (bytes[] memory returnData);\n}\n"},"contracts/interfaces/base/IAccountConfig.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { ExecutionMode } from \"../../lib/ModeLib.sol\";\n\n/// @title Nexus - ERC-7579 Account Configuration Interface\n/// @notice Interface for querying and verifying configurations of Smart Accounts compliant with ERC-7579.\n/// @dev Provides methods to check supported execution modes and module types for Smart Accounts, ensuring flexible and extensible configuration.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IAccountConfig {\n    /// @notice Returns the account ID in a structured format: \"vendorname.accountname.semver\"\n    /// @return accountImplementationId The account ID of the smart account\n    function accountId() external view returns (string memory accountImplementationId);\n\n    /// @notice Checks if the account supports a certain execution mode.\n    /// @param encodedMode The encoded mode to verify.\n    /// @return supported True if the account supports the mode, false otherwise.\n    function supportsExecutionMode(ExecutionMode encodedMode) external view returns (bool supported);\n\n    /// @notice Checks if the account supports a specific module type.\n    /// @param moduleTypeId The module type ID to verify.\n    /// @return supported True if the account supports the module type, false otherwise.\n    function supportsModule(uint256 moduleTypeId) external view returns (bool supported);\n}\n"},"contracts/interfaces/base/IModuleManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { IModuleManagerEventsAndErrors } from \"./IModuleManagerEventsAndErrors.sol\";\n\n/// @title Nexus - IModuleManager\n/// @notice Interface for managing modules within Smart Accounts, providing methods for installation and removal of modules.\n/// @dev Extends the IModuleManagerEventsAndErrors interface to include event and error definitions.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IModuleManager is IModuleManagerEventsAndErrors {\n    /// @notice Installs a Module of a specific type onto the smart account.\n    /// @param moduleTypeId The identifier for the module type.\n    /// @param module The address of the module to be installed.\n    /// @param initData Initialization data for configuring the module upon installation.\n    function installModule(uint256 moduleTypeId, address module, bytes calldata initData) external payable;\n\n    /// @notice Uninstalls a Module of a specific type from the smart account.\n    /// @param moduleTypeId The identifier for the module type being uninstalled.\n    /// @param module The address of the module to uninstall.\n    /// @param deInitData De-initialization data for configuring the module upon uninstallation.\n    function uninstallModule(uint256 moduleTypeId, address module, bytes calldata deInitData) external payable;\n\n    /// @notice Checks if a specific module is installed on the smart account.\n    /// @param moduleTypeId The module type identifier to check.\n    /// @param module The address of the module.\n    /// @param additionalContext Additional information that may be required to verify the module's installation.\n    /// @return installed True if the module is installed, false otherwise.\n    function isModuleInstalled(uint256 moduleTypeId, address module, bytes calldata additionalContext) external view returns (bool installed);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IStakeManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.5;\n\n/**\n * Manage deposits and stakes.\n * Deposit is just a balance used to pay for UserOperations (either by a paymaster or an account).\n * Stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    // Emitted when stake or unstake delay are modified.\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    // Emitted once a stake is scheduled for withdrawal.\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit         - The entity's deposit.\n     * @param staked          - True if this entity is staked.\n     * @param stake           - Actual amount of ether staked for this entity.\n     * @param unstakeDelaySec - Minimum delay to withdraw the stake.\n     * @param withdrawTime    - First block timestamp where 'withdrawStake' will be callable, or zero if already locked.\n     * @dev Sizes were chosen so that deposit fits into one cell (used during handleOp)\n     *      and the rest fit into a 2nd cell (used during stake/unstake)\n     *      - 112 bit allows for 10^15 eth\n     *      - 48 bit for full timestamp\n     *      - 32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint256 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    // API struct used by getStakeInfo and simulateValidation.\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /**\n     * Get deposit info.\n     * @param account - The account to query.\n     * @return info   - Full deposit information of given account.\n     */\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /**\n     * Get account balance.\n     * @param account - The account to query.\n     * @return        - The deposit (for gas payment) of the account.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * Add to the deposit of the given account.\n     * @param account - The account to add to.\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * Add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec - The new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * Attempt to unlock the stake.\n     * The value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * Withdraw from the (unlocked) stake.\n     * Must first call unlockStake and wait for the unstakeDelay to pass.\n     * @param withdrawAddress - The address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * Withdraw from the deposit.\n     * @param withdrawAddress - The address to send withdrawn value.\n     * @param withdrawAmount  - The amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"},"node_modules/account-abstraction/contracts/interfaces/IAggregator.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\nimport \"./PackedUserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * Validate aggregated signature.\n     * Revert if the aggregated signature does not match the given list of operations.\n     * @param userOps   - Array of UserOperations to validate the signature for.\n     * @param signature - The aggregated signature.\n     */\n    function validateSignatures(\n        PackedUserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * Validate signature of a single userOp.\n     * This method should be called by bundler after EntryPointSimulation.simulateValidation() returns\n     * the aggregator this account uses.\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp        - The userOperation received from the user.\n     * @return sigForUserOp - The value to put into the signature field of the userOp when calling handleOps.\n     *                        (usually empty, unless account and aggregator support some kind of \"multisig\".\n     */\n    function validateUserOpSignature(\n        PackedUserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * Aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation.\n     * @param userOps              - Array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature - The aggregated signature.\n     */\n    function aggregateSignatures(\n        PackedUserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"},"node_modules/account-abstraction/contracts/interfaces/INonceManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.5;\n\ninterface INonceManager {\n\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(address sender, uint192 key)\n    external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"},"contracts/interfaces/base/IBaseAccountEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution Manager Events and Errors Interface\n/// @notice Interface for defining events and errors related to transaction execution processes within smart accounts.\n/// @dev This interface defines events and errors used by execution manager to handle and report the operational status of smart account transactions.\n/// It is a part of the Nexus suite of contracts aimed at implementing flexible and secure smart account operations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IBaseAccountEventsAndErrors {\n    /// @dev Throws an error when a caller is not authorized to access an account.\n    error AccountAccessUnauthorized();\n}\n"},"contracts/interfaces/base/IStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\nimport { SentinelListLib } from \"sentinellist/SentinelList.sol\";\n\nimport { IHook } from \"../modules/IHook.sol\";\nimport { CallType } from \"../../lib/ModeLib.sol\";\n\n/// @title Nexus - IStorage Interface\n/// @notice Provides structured storage for Modular Smart Account under the Nexus suite, compliant with ERC-7579 and ERC-4337.\n/// @dev Manages structured storage using SentinelListLib for validators and executors, and a mapping for fallback handlers.\n/// This interface utilizes ERC-7201 storage location practices to ensure isolated and collision-resistant storage spaces within smart contracts.\n/// It is designed to support dynamic execution and modular management strategies essential for advanced smart account architectures.\n/// @custom:storage-location erc7201:biconomy.storage.Nexus\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\ninterface IStorage {\n    /// @notice Struct storing validators and executors using Sentinel lists, and fallback handlers via mapping.\n    struct AccountStorage {\n        SentinelListLib.SentinelList validators; ///< List of validators, initialized upon contract deployment.\n        SentinelListLib.SentinelList executors; ///< List of executors, similarly initialized.\n        mapping(bytes4 => FallbackHandler) fallbacks; ///< Mapping of selectors to their respective fallback handlers.\n        IHook hook; ///< Current hook module associated with this account.\n        mapping(address hook => uint256) emergencyUninstallTimelock; ///< Mapping of hooks to requested timelocks.\n    }\n\n    /// @notice Defines a fallback handler with an associated handler address and a call type.\n    struct FallbackHandler {\n        address handler; ///< The address of the fallback function handler.\n        CallType calltype; ///< The type of call this handler supports (e.g., static or call).\n    }\n}\n"},"contracts/interfaces/base/IExecutionHelperEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.27;\n\n// ──────────────────────────────────────────────────────────────────────────────\n//     _   __    _  __\n//    / | / /__ | |/ /_  _______\n//   /  |/ / _ \\|   / / / / ___/\n//  / /|  /  __/   / /_/ (__  )\n// /_/ |_/\\___/_/|_\\__,_/____/\n//\n// ──────────────────────────────────────────────────────────────────────────────\n// Nexus: A suite of contracts for Modular Smart Accounts compliant with ERC-7579 and ERC-4337, developed by Biconomy.\n// Learn more at https://biconomy.io. To report security issues, please contact us at: security@biconomy.io\n\n/// @title Execution Manager Events and Errors Interface\n/// @notice Interface for defining events and errors related to transaction execution processes within smart accounts.\n/// @dev This interface defines events and errors used by execution manager to handle and report the operational status of smart account transactions.\n/// It is a part of the Nexus suite of contracts aimed at implementing flexible and secure smart account operations.\n/// @author @livingrockrises | Biconomy | chirag@biconomy.io\n/// @author @aboudjem | Biconomy | adam.boudjemaa@biconomy.io\n/// @author @filmakarov | Biconomy | filipp.makarov@biconomy.io\n/// @author @zeroknots | Rhinestone.wtf | zeroknots.eth\n/// Special thanks to the Solady team for foundational contributions: https://github.com/Vectorized/solady\n\nimport { ExecType } from \"../../lib/ModeLib.sol\";\n\ninterface IExecutionHelperEventsAndErrors {\n    /// @notice Event emitted when a transaction fails to execute successfully.\n    event TryExecuteUnsuccessful(bytes callData, bytes result);\n\n    /// @notice Event emitted when a transaction fails to execute successfully.\n    event TryDelegateCallUnsuccessful(bytes callData, bytes result);\n\n    /// @notice Error thrown when an execution with an unsupported ExecType was made.\n    /// @param execType The unsupported execution type.\n    error UnsupportedExecType(ExecType execType);\n}\n"}},"settings":{"remappings":["@openzeppelin/=node_modules/@openzeppelin/","forge-std/=node_modules/forge-std/src/","account-abstraction/=node_modules/account-abstraction/contracts/","solady/=node_modules/solady/src/","excessively-safe-call/=node_modules/excessively-safe-call/src/","sentinellist/=node_modules/sentinellist/src/","solarray/=node_modules/solarray/src/","erc7739Validator/=node_modules/erc7739-validator-base/src/","@ERC4337/=node_modules/@ERC4337/","@biconomy/=node_modules/@biconomy/","@erc7579/=node_modules/@erc7579/","@gnosis.pm/=node_modules/@gnosis.pm/","@prb/=node_modules/@prb/","@rhinestone/=node_modules/@rhinestone/","@safe-global/=node_modules/@safe-global/","@zerodev/=node_modules/@zerodev/","ExcessivelySafeCall/=node_modules/erc7739-validator-base/node_modules/excessively-safe-call/src/","account-abstraction-v0.6/=node_modules/account-abstraction-v0.6/","ds-test/=node_modules/ds-test/","enumerableset4337/=node_modules/erc7739-validator-base/node_modules/@erc7579/enumerablemap4337/src/","erc4337-validation/=node_modules/erc7739-validator-base/node_modules/@rhinestone/erc4337-validation/src/","erc7579/=node_modules/erc7579/","erc7739-validator-base/=node_modules/erc7739-validator-base/","eth-gas-reporter/=node_modules/eth-gas-reporter/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","kernel/=node_modules/erc7739-validator-base/node_modules/@zerodev/kernel/src/","module-bases/=node_modules/erc7739-validator-base/node_modules/@rhinestone/module-bases/src/","modulekit/=node_modules/erc7739-validator-base/node_modules/@rhinestone/modulekit/src/","prep/=node_modules/prep/","safe7579/=node_modules/erc7739-validator-base/node_modules/@rhinestone/safe7579/src/"],"optimizer":{"enabled":true,"runs":999},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
